// scripts/seed-all.ts
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs';
import yargs from 'yargs/yargs';
import { hideBin } from 'yargs/helpers';
import { Pool, type PoolClient } from 'pg';
import { createPool, type Pool as MySqlPool, type PoolConnection } from 'mysql2/promise';
import sampleData from '../src/sample-data.local.json';

type DbClient = PoolClient | PoolConnection;

const envPathLocal = path.resolve(process.cwd(), '.env.local');
if (fs.existsSync(envPathLocal)) {
  dotenv.config({ path: envPathLocal });
} else {
  dotenv.config();
}

const formatValue = (value: any, dbType: 'postgres' | 'mysql'): any => {
    if (value instanceof Date) {
        return value.toISOString().slice(0, 19).replace('T', ' ');
    }
    if (value === null || value === undefined) {
        return null;
    }
    if (typeof value === 'boolean') {
        return value;
    }
    if (typeof value === 'object') {
        return JSON.stringify(value);
    }
    return value;
};

const seedTable = async (client: DbClient, tableName: string, data: any[], idMap: Map<string, number>, dependencies: { [key: string]: Map<string, number> }, dbType: 'postgres' | 'mysql') => {
    console.log(`\nSeeding ${tableName}...`);
    for (const item of data) {
        const newItem = { ...item };

        // Replace foreign keys with new integer IDs from maps
        for (const key in dependencies) {
            if (newItem[key]) {
                const newFkId = dependencies[key].get(newItem[key]);
                if (newFkId) {
                    newItem[key] = newFkId;
                } else {
                    console.warn(`  - Warning: Could not find mapping for ${key}: ${newItem[key]} in ${tableName}`);
                    newItem[key] = null; // Set to null if mapping not found
                }
            }
        }
        
        const oldId = item.id;
        delete newItem.id;
        delete newItem.publicId; // publicId is usually auto-generated by DB or adapter logic
        
        const columns = Object.keys(newItem).map(key => key.replace(/([A-Z])/g, '_$1').toLowerCase()).join(', ');
        const values = Object.values(newItem);

        let query;
        let formattedValues = values.map(v => formatValue(v, dbType));

        if (dbType === 'postgres') {
            const placeholders = values.map((_, i) => `$${i + 1}`).join(', ');
            query = `INSERT INTO ${tableName} (${columns}) VALUES (${placeholders}) RETURNING id`;
        } else { // mysql
            const placeholders = values.map(() => '?').join(', ');
            query = `INSERT INTO ${tableName} (${columns}) VALUES (${placeholders})`;
        }

        try {
            if (dbType === 'postgres') {
                const res = await (client as PoolClient).query(query, formattedValues);
                idMap.set(oldId, res.rows[0].id);
            } else {
                const [res] = await (client as PoolConnection).execute(query, formattedValues);
                idMap.set(oldId, (res as any).insertId);
            }
        } catch (error: any) {
            console.error(`  - FAILED to insert item into ${tableName}. Error: ${error.message}`);
            console.error(`    - Query: ${query}`);
            console.error(`    - Values:`, formattedValues);
        }
    }
    console.log(`  - Finished seeding ${tableName}. ${data.length} items processed.`);
};

async function main() {
    const argv = await yargs(hideBin(process.argv))
        .option('db', {
            alias: 'database',
            type: 'string',
            description: 'Specify the database type to seed (postgres or mysql)',
            choices: ['postgres', 'mysql'],
            demandOption: true,
        })
        .help().alias('help', 'h').argv;

    const dbType = argv.db as 'postgres' | 'mysql';
    let client: DbClient;
    let pgPool: Pool | undefined;
    let mysqlPool: MySqlPool | undefined;

    console.log(`--- Starting full data seed for ${dbType.toUpperCase()} ---`);

    try {
        // Connect to the database
        if (dbType === 'postgres') {
            pgPool = new Pool({ connectionString: process.env.POSTGRES_CONNECTION_STRING });
            client = await pgPool.connect();
        } else {
            mysqlPool = createPool(process.env.MYSQL_CONNECTION_STRING!);
            client = await mysqlPool.getConnection();
        }
        console.log("Database connection successful.");

        // Clear tables
        console.log("Clearing existing data...");
        const tables = [
            'bids', 'user_wins', 'lots', 'auctions', 'bens', 'process_parties', 'judicial_processes', 'judicial_branches', 'judicial_districts', 'courts', 'sellers', 'auctioneers', 'cities', 'states', 'subcategories', 'lot_categories', 'users', 'roles'
        ];
        
        if (dbType === 'postgres') {
             await (client as PoolClient).query(`TRUNCATE TABLE ${tables.join(', ')} RESTART IDENTITY CASCADE;`);
        } else {
            await (client as PoolConnection).query('SET FOREIGN_KEY_CHECKS = 0;');
            for(const table of tables) {
                await (client as PoolConnection).query(`TRUNCATE TABLE ${table};`);
            }
            await (client as PoolConnection).query('SET FOREIGN_KEY_CHECKS = 1;');
        }
        console.log("Tables cleared successfully.");

        // ID Mappings
        const roleIdMap = new Map<string, number>();
        const categoryIdMap = new Map<string, number>();
        const auctioneerIdMap = new Map<string, number>();
        const sellerIdMap = new Map<string, number>();

        // Seed data in order of dependency
        await seedTable(client, 'roles', sampleData.sampleRoles, roleIdMap, {}, dbType);
        
        // This is a simplified user seeding, in real scenario, this would be more complex
        const userDataWithRoles = sampleData.sampleUserProfiles.map(u => ({...u, roleId: roleIdMap.get(u.roleId || '') || null }));
        await seedTable(client, 'users', userDataWithRoles, new Map(), { roleId: roleIdMap }, dbType);
        
        await seedTable(client, 'lot_categories', sampleData.sampleLotCategories, categoryIdMap, {}, dbType);
        await seedTable(client, 'auctioneers', sampleData.sampleAuctioneers, auctioneerIdMap, {}, dbType);
        await seedTable(client, 'sellers', sampleData.sampleSellers, sellerIdMap, {}, dbType);

        // Seed auctions
        const auctionDataWithFks = sampleData.sampleAuctions.map(a => ({
          ...a,
          categoryId: categoryIdMap.get(a.categoryId!),
          auctioneerId: auctioneerIdMap.get(a.auctioneerId!),
          sellerId: sellerIdMap.get(a.sellerId!),
        }));
        await seedTable(client, 'auctions', auctionDataWithFks, new Map(), {}, dbType);

        console.log("\n--- Data Seeding Complete! ---");

    } catch (error: any) {
        console.error("An error occurred during the seeding process:", error);
    } finally {
        if (client) {
            if ('release' in client) client.release();
            else client.end();
            console.log("Database connection closed.");
        }
        if (pgPool) await pgPool.end();
        if (mysqlPool) await mysqlPool.end();
    }
}

main();
