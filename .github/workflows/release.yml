# ==============================================================================
# GitHub Action: Semantic Release - Versionamento AutomÃ¡tico
# ==============================================================================
# Trigger: Push nas branches main, demo-stable e hml
# Responsabilidade: Analisa commits, gera versÃ£o SemVer, atualiza CHANGELOG.md,
#   cria Git Tag e GitHub Release, injeta versÃ£o como env var para Vercel
# ==============================================================================

name: Semantic Release

on:
  push:
    branches:
      - main
      - demo-stable
      - hml

permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  NODE_VERSION: '20'

jobs:
  # ============================================================================
  # JOB 1: Quality Gate (lint + typecheck + build validation)
  # ============================================================================
  quality-gate:
    name: ğŸ” Quality Gate
    runs-on: ubuntu-latest

    steps:
      - name: ğŸ“¥ Checkout code (full history para semantic-release)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ“š Install dependencies
        run: npm ci

      - name: ğŸ”„ Copy PostgreSQL schema
        run: cp prisma/schema.postgresql.prisma prisma/schema.prisma

      - name: ğŸ—„ï¸ Generate Prisma Client
        run: npx prisma generate

      - name: ğŸ§¹ Lint
        run: npm run lint
        continue-on-error: true

      - name: ğŸ“ Type Check
        run: npm run typecheck
        continue-on-error: true

      - name: ğŸ—ï¸ Build Validation
        run: npm run build
        env:
          SESSION_SECRET: 'ci-build-secret-key-at-least-32-chars-long!'
          NEXTAUTH_SECRET: 'ci-build-nextauth-secret-32chars!'

  # ============================================================================
  # JOB 2: Semantic Release (versÃ£o + changelog + tag + GitHub Release)
  # ============================================================================
  release:
    name: ğŸš€ Semantic Release
    runs-on: ubuntu-latest
    needs: quality-gate
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
      new_release_channel: ${{ steps.semantic.outputs.new_release_channel }}

    steps:
      - name: ğŸ“¥ Checkout code (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ“š Install dependencies
        run: npm ci

      - name: ğŸ”– Run Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GIT_AUTHOR_NAME: 'github-actions[bot]'
          GIT_AUTHOR_EMAIL: 'github-actions[bot]@users.noreply.github.com'
          GIT_COMMITTER_NAME: 'github-actions[bot]'
          GIT_COMMITTER_EMAIL: 'github-actions[bot]@users.noreply.github.com'
        run: npx semantic-release

      - name: ğŸ“Š Release Summary
        if: steps.semantic.outputs.new_release_published == 'true'
        run: |
          echo "============================================"
          echo "ğŸ‰ NOVA VERSÃƒO PUBLICADA!"
          echo "============================================"
          echo "ğŸ“¦ VersÃ£o: ${{ steps.semantic.outputs.new_release_version }}"
          echo "ğŸ“¢ Canal: ${{ steps.semantic.outputs.new_release_channel || 'latest' }}"
          echo "ğŸ·ï¸ Tag: v${{ steps.semantic.outputs.new_release_version }}"
          echo "ğŸŒ¿ Branch: ${{ github.ref_name }}"
          echo "============================================"

      - name: â­ï¸ No Release Needed
        if: steps.semantic.outputs.new_release_published != 'true'
        run: |
          echo "============================================"
          echo "â„¹ï¸  Nenhuma versÃ£o nova necessÃ¡ria."
          echo "    Commits desde a Ãºltima versÃ£o nÃ£o incluem"
          echo "    feat:, fix:, perf: ou breaking changes."
          echo "============================================"

  # ============================================================================
  # JOB 3: Inject Version into Vercel (atualiza env var NEXT_PUBLIC_APP_VERSION)
  # ============================================================================
  inject-version:
    name: ğŸ’‰ Inject Version into Vercel
    runs-on: ubuntu-latest
    needs: release
    if: needs.release.outputs.new_release_published == 'true'

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ğŸ”§ Install Vercel CLI
        run: npm install -g vercel@latest

      - name: ğŸ’‰ Set NEXT_PUBLIC_APP_VERSION on Vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          VERSION="${{ needs.release.outputs.new_release_version }}"
          BRANCH="${{ github.ref_name }}"
          
          echo "ğŸ”§ Injetando NEXT_PUBLIC_APP_VERSION=$VERSION para branch $BRANCH..."
          
          # Determinar o environment target na Vercel
          if [ "$BRANCH" = "main" ]; then
            TARGET="production"
          else
            TARGET="preview"
          fi
          
          # Remover variÃ¡vel existente (ignora erro se nÃ£o existir)
          vercel env rm NEXT_PUBLIC_APP_VERSION "$TARGET" --yes --token="$VERCEL_TOKEN" 2>/dev/null || true
          
          # Adicionar nova variÃ¡vel
          echo "$VERSION" | vercel env add NEXT_PUBLIC_APP_VERSION "$TARGET" --token="$VERCEL_TOKEN"
          
          echo "âœ… NEXT_PUBLIC_APP_VERSION=$VERSION configurado para $TARGET"

      - name: ğŸ”„ Trigger Vercel Redeploy
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          BRANCH="${{ github.ref_name }}"
          
          if [ "$BRANCH" = "main" ]; then
            echo "ğŸš€ Triggering production redeploy..."
            vercel deploy --prod --yes --token="$VERCEL_TOKEN"
          else
            echo "ğŸš€ Triggering preview redeploy for $BRANCH..."
            vercel deploy --yes --token="$VERCEL_TOKEN"
          fi

  # ============================================================================
  # JOB 4: Database Migration (para produÃ§Ã£o e demo)
  # ============================================================================
  migrate:
    name: ğŸ—ƒï¸ Database Migration
    runs-on: ubuntu-latest
    needs: release
    if: >
      needs.release.outputs.new_release_published == 'true' &&
      (github.ref_name == 'main' || github.ref_name == 'demo-stable')

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ“š Install dependencies
        run: npm ci

      - name: ğŸ”„ Copy PostgreSQL schema
        run: cp prisma/schema.postgresql.prisma prisma/schema.prisma

      - name: ğŸ—„ï¸ Generate Prisma Client
        run: npx prisma generate

      - name: ğŸ—ƒï¸ Run Prisma Migrate Deploy
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: ${{ github.ref_name == 'main' && secrets.PROD_DATABASE_URL_DIRECT || secrets.DEMO_DATABASE_URL_DIRECT }}

      - name: âœ… Verify Migration
        run: |
          echo "ğŸ” Verificando estado do banco de dados..."
          npx prisma migrate status
        env:
          DATABASE_URL: ${{ github.ref_name == 'main' && secrets.PROD_DATABASE_URL_DIRECT || secrets.DEMO_DATABASE_URL_DIRECT }}

  # ============================================================================
  # JOB 5: Notification
  # ============================================================================
  notify:
    name: ğŸ“¢ Release Notification
    runs-on: ubuntu-latest
    needs: [release, inject-version, migrate]
    if: always() && needs.release.outputs.new_release_published == 'true'

    steps:
      - name: ğŸ“¢ Release Report
        run: |
          echo "============================================"
          echo "ğŸ“‹ RELEASE REPORT"
          echo "============================================"
          echo "ğŸ“¦ VersÃ£o: ${{ needs.release.outputs.new_release_version }}"
          echo "ğŸ“¢ Canal: ${{ needs.release.outputs.new_release_channel || 'production' }}"
          echo "ğŸŒ¿ Branch: ${{ github.ref_name }}"
          echo "ğŸ”– Release: ${{ needs.release.result }}"
          echo "ğŸ’‰ Version Inject: ${{ needs.inject-version.result || 'skipped' }}"
          echo "ğŸ—ƒï¸ Migration: ${{ needs.migrate.result || 'skipped' }}"
          echo "============================================"
          
          # Mapeamento de branch para ambiente
          case "${{ github.ref_name }}" in
            main)
              echo "ğŸŒ Ambiente: PRODUÃ‡ÃƒO"
              echo "ğŸ”— URL: https://bidexpertaifirebasestudio.vercel.app"
              ;;
            demo-stable)
              echo "ğŸŒ Ambiente: DEMONSTRAÃ‡ÃƒO"
              echo "ğŸ”— URL: https://demo-bidexpertaifirebasestudio.vercel.app"
              ;;
            hml)
              echo "ğŸŒ Ambiente: HOMOLOGAÃ‡ÃƒO"
              echo "ğŸ”— URL: https://hml-bidexpertaifirebasestudio.vercel.app"
              ;;
          esac
