O conteúdo FINAL e COMPLETO do arquivo deve ser colocado aqui. Não forneça diffs ou trechos parciais.
    
```
## 4. Princípio da Não-Regressão e Autorização Humana

**Regra:** Qualquer exclusão de funcionalidade, componente ou alteração significativa no projeto **deve ser explicitamente autorizada por um usuário humano**. Para evitar a remoção acidental de funcionalidades que estão operando corretamente ao implementar correções ou melhorias, a IA deve:

1.  Declarar claramente a intenção de excluir ou refatorar um componente/arquivo/funcionalidade.
2.  Fornecer uma breve justificativa sobre por que a mudança é necessária.
3.  Solicitar confirmação explícita do usuário antes de gerar as alterações.

**Justificativa:** Este princípio garante que o processo de desenvolvimento esteja sempre avançando e evita regressões. Ele mantém uma salvaguarda onde o desenvolvedor humano tem a palavra final sobre quaisquer alterações destrutivas ou em larga escala, preservando a estabilidade e a integridade do projeto.

## 5. Gerenciamento de Dependências

**Regra:** Para manter o projeto otimizado e evitar o crescimento excessivo do diretório `node_modules` e dos pacotes de produção, siga estas diretrizes:
-   **Dependências de Desenvolvimento:** Pacotes usados exclusivamente para desenvolvimento, teste ou processos de build (e.g., `@playwright/test`, `puppeteer` para geração de PDF no servidor) **devem** ser instalados como `devDependencies`. Isso impede que eles sejam incluídos no build de produção.
-   **Análise de Pacotes Pesados:** Antes de adicionar uma nova dependência, especialmente para funcionalidades não essenciais, avalie seu tamanho e impacto.
-   **Revisão Periódica:** Revise periodicamente o `package.json` para remover dependências não utilizadas.

**Justificativa:** Um `node_modules` grande e pacotes de produção inchados podem levar a tempos de instalação mais longos, builds mais lentos e custos de hospedagem mais altos. Manter as dependências limpas e otimizadas é crucial para a saúde do projeto.

## 6. Integridade de Links (Next.js)

**Regra:** Nunca permita que a propriedade `href` de um componente `<Link>` do Next.js seja `undefined`.

-   **Validação Obrigatória:** Se o `href` for dinâmico (vindo de uma API, props, ou estado), sempre valide se o valor existe antes de renderizar o `<Link>`.
-   **Estratégias de Fallback:**
    -   Use um link padrão (e.g., `href={item.url || '#'}`).
    -   Renderize o link condicionalmente (e.g., `{item.url && <Link.../>}`).
    -   Renderize um elemento alternativo (e.g., `<span>`) se o link não estiver disponível.

**Justificativa:** Um `href` indefinido causa um erro fatal de renderização no Next.js (`Error: Failed prop type`). Garantir a validade do `href` previne crashes e melhora a robustez da aplicação.

## 7. Estratégia de Testes para Aplicação de Leilões Full-Stack
### 1. Camadas e Tipos de Teste
Testes Unitários: Validam pequenas unidades de código isoladamente (funções, métodos, validações). São rápidos e não dependem de banco de dados ou rede, focando apenas na lógica interna. Por exemplo, testar uma função que calcula o próximo lance válido ou valida se um campo obrigatório está presente. Esse tipo de teste “isola a lógica garantindo que cada unidade funcione como esperado”
mendoncadev.com.br
.
Testes de Integração: Verificam a interação entre componentes ou módulos, incluindo acesso a banco de dados ou APIs externas. Por exemplo, testar um endpoint REST de cadastro de usuário usando um servidor Express e um banco MySQL real via Docker. Isso garante que controladores, serviços e camada de dados estão integrados corretamente. Os testes de integração “garantem que módulos e componentes do sistema funcionem corretamente juntos”
mendoncadev.com.br
.
Testes End-to-End (E2E): Simulam fluxos completos do usuário final, exercitando toda a pilha (front-end, back-end, banco de dados, etc.). Por exemplo, um teste E2E pode abrir a interface web do leilão, registrar um usuário, habilitá-lo, efetuar lances válidos/inválidos e gerar relatórios, tudo via UI ou API. Os testes E2E “verificam a funcionalidade completa do aplicativo do início ao fim, simulando cenários reais de usuários”
apidog.com
. Eles são mais lentos e devem focar em jornadas críticas (p. ex. finalização de leilão), deixando os detalhes menores para testes unitários.
### 2. Consistência de Schemas
Para evitar divergências entre o banco de dados, o schema do Prisma e os esquemas Zod:
Migrations e Versionamento: Sempre use Prisma Migrate para controlar alterações do schema MySQL. Toda modificação no model do Prisma deve ser migrada ao banco (via prisma migrate), garantindo que o BD real reflita o schema Prisma.
Geradores Automáticos: Utilize geradores que sincronizam Zod e Prisma. Por exemplo, o zod-prisma cria automaticamente esquemas Zod baseados no modelo Prisma, evitando ter que manter manualmente cada mudança de schema
github.com
. Bibliotecas NPM como prisma-zod-generator ou zod-prisma geram código Zod a partir do modelo, mantendo-os 1:1.
Validações Automatizadas: Além do tsc (TypeScript) que já aponta inconsistências de tipo, considere testes que carreguem os esquemas Zod gerados e comparem contra a saída do banco. Ferramentas como zod-fixture geram fixtures de teste a partir de esquemas Zod
github.com
, ajudando a validar entradas/saídas. Outra prática é escrever testes que tentem gravar entradas inválidas (segundo o Zod) no BD, confirmando que o middleware de validação bloqueia o acesso indevido. Dessa forma, o schema Zod (API) e o schema Prisma (BD) permanecem alinhados.
### 3. Cobertura de Funcionalidades do Leilão
Teste todos os fluxos principais da aplicação de leilões:
Cadastro e Habilitação: Teste unitário para validar regras de formato de dados de cadastro. Testes de integração via API para verificar que /api/usuarios cria o usuário no banco e que háflows como envio de e-mail ou notificações. Por exemplo, com Supertest pode-se validar que POST /api/usuarios retorna 201 e corpo JSON contendo o ID gerado.
Lances Válidos/Inválidos: Em lógica de negócios, escreva testes unitários para regras de lance (p. ex. “um lance deve ser maior que o último lance válido ou seguir incremento mínimo”). Em testes de integração, faça chamadas ao endpoint de lances (ex.: POST /api/lances) inserindo dados válidos e inválidos, verificando códigos de resposta e mensagens de erro. Por exemplo:
import request from 'supertest';
import { app } from '../src/app';

describe('POST /api/lances', () => {
  it('deve rejeitar lance abaixo do mínimo', async () => {
    const res = await request(app)
      .post('/api/lances')
      .send({ valor: 0.50, loteId: 'abc123', usuarioId: 1 });
    expect(res.status).toBe(400);
    expect(res.body).toHaveProperty('erro');
  });
});
Encerramento de Leilão: Teste a rotina que encerra o leilão (cron job ou função manual). Por exemplo, ao simular o fim do prazo, verificar que o status do leilão passa para “encerrado” e um vencedor é definido. Escreva testes de integração para endpoints de finalização ou simulação de tempo, garantindo atualização correta do BD.
Geração de Relatórios: Se a aplicação gera relatórios (por exemplo, somatório de lances ou visitas por leilão), crie testes que insiram dados no BD e consultem a API de relatório, verificando consistência dos valores agregados. Teste queries complexas no banco usando fixtures de dados.
Consultas com Joins Complexos: Para funcionalidades que exibem dados combinados (p. ex. cards de visitação que mostram Leilão + Lote + Comitente + Lances + Visitas), escreva testes de integração/prisma que gerem registros de cada entidade e consultem via Prisma com include ou join. Por exemplo:
const visita = await prisma.visita.findFirst({
  include: { leilao: true, lote: true, comitente: true, lances: true }
});
expect(visita).toMatchObject({
  leilao: { /* dados do leilão esperado */ },
  lote: { /* dados do lote */ },
  comitente: { /* dados do comitente */ },
  lances: expect.any(Array)
});
Isso garante que a consulta traga todas as relações corretas. Em testes E2E, valide também a interface (front-end) exibindo corretamente esses dados complexos.
### 4. Estratégia de Banco de Testes
Banco Real Isolado: Use uma instância MySQL separada (via Docker) para os testes. Um container mysql:8 isolado evita interferir nos dados de desenvolvimento. Configure o .env.test ou variável DATABASE_URL apontando para esse DB de teste. Em CI, você pode usar serviços do GitHub Actions ou Docker Compose para provisionar o MySQL antes dos testes.
Setup/Reset: Antes da suíte de testes, aplique as migrações: por exemplo, npx prisma migrate deploy ou prisma migrate reset --force. Entre cada teste (ou suíte), limpe o estado do banco – isso pode ser feito via transações que são revertidas (jdbc), truncando tabelas ou recriando o banco entre suites. Em frameworks como Jest/Vitest, use hooks beforeAll e afterAll para inicializar e limpar. Garantir que cada teste comece de um estado conhecido elimina efeitos colaterais.
Ambiente de Teste Separado: Utilize variáveis de ambiente para diferenciar ambiente de teste. Por exemplo, NODE_ENV=test ou DATABASE_URL distinta. Isso evita rodar testes em bases de dados de produção ou desenvolvimento. No código de inicialização do app, carregue o .env.test quando apropriado. Além disso, prefira configurações específicas de teste (sem portas em uso, logs reduzidos) para manter a performance do pipeline.
### 5. Ferramentas Recomendadas
Test Runner (Unit/Integração): Vitest e Jest são os mais usados. O Vitest é um runner moderno que funciona muito bem com projetos Vite/Next.js e TypeScript. Ele oferece API compatível com Jest e destacável foco em velocidade (“Vite significa rápido” – muitas vezes executa testes diversas vezes mais rápido que Jest)
saucelabs.com
. Jest é maduro, amplamente suportado e não exige configuração extra para projetos comuns. Em geral, Vitest tende a ser recomendado para projetos com Vite ou Next.js modernos devido à performance, enquanto Jest é sólido se você já o conhece ou precisa de recursos avançados como snapshot testing.
Simulação de APIs (Integração): Supertest é excelente para testar endpoints HTTP em aplicações Express/Koa/etc
mendoncadev.com.br
. Ele permite emitir requisições (GET, POST, etc.) diretamente contra o servidor em memória. Use-o para testes de integração REST. Outra opção é Axios combinado com um servidor local ou nock para simular respostas de serviços externos.
Validação de Dados: Para criar dados de teste consistentes a partir de esquemas, use zod-fixture, que “cria fixtures de teste baseados em um schema Zod”
github.com
. Com ele você evita criar manualmente objetos de teste. Também considere bibliotecas como faker.js para dados randômicos e Prisma Factory (npm) para construir entidades completas.
Testes End-to-End: Playwright (Microsoft) é uma ferramenta robusta de E2E que suporta múltiplos navegadores e linguagens. Ao contrário do Cypress (que roda dentro do navegador e é limitado a JS/TS), o Playwright roda fora e oferece suporte a diversos navegadores e paralelismo embutido
checklyhq.com
. O Cypress tem ótima experiência de uso e depuração integrada, mas não suporta Safari nem múltiplas abas, e o paralelismo requer serviço pago. Recomenda-se Playwright para testes E2E amplos (ex.: fluxos completos de usuário) e Cypress se focar em testes front-end JS/TS com feedback interativo.
Outras Ferramentas: Para teste de front-end React, use Testing Library (React Testing Library) ou Vitest com JSDOM para componentes UI isolados. Para bancos em memória, considere SQLite in-memory ou Prisma DSN especial. Ferramentas de CI de testes (como Coveralls) podem ser integradas posteriormente, mas foque primeiro na cobertura de funcionalidades.
### 6. Integração com Firebase Studio
Prototyper de IA (App Prototyping Agent): O Firebase Studio inclui um agente de prototipagem por IA (chamado Prototyper ou App Prototyping agent) que gera automaticamente código de aplicação full-stack a partir de prompts multimodais
firebase.google.com
. Ao descrever a ideia da app em linguagem natural, o agente cria um “blueprint”, o código-fonte correspondente e um preview da aplicação. Esse código gerado é injetado diretamente no workspace (IDE VSCode) do Firebase Studio, permitindo que o desenvolvedor revise ou modifique imediatamente no ambiente de código. Em outras palavras, o desenvolvedor trabalha no VSCode web do Firebase Studio e o Prototyper populos generationa arquivos editáveis nesse mesmo editor
firebase.google.com
.
Testando o Preview (VM Fechada): O preview da aplicação no Firebase Studio roda numa VM isolada. Para testar via scripts externos (Playwright, etc.), use a funcionalidade “Make Preview Public”. No próprio Firebase Studio, abra o preview web e clique em “Make Preview Public” na toolbar
firebase.blog
. Isso libera um URL externo (indicado por um ícone de globo amarelo) que qualquer máquina pode acessar temporariamente. A figura abaixo mostra como fica o painel de portas e o botão de pré-visualização pública: Figura: No Firebase Studio, abra o painel “Backend Ports” (Ctrl+',' → “Backend Ports”) e clique no cadeado para liberar a porta do backend publicamente
firebase.blog
. Uma vez liberada, aparece o ícone de globo que indica URL público. Figura: Na aba de preview web do Firebase Studio, clique em “Make Preview Public” (ícone de cadeado) para obter um link público da aplicação
firebase.blog
. O ícone muda para globo amarelo, sinalizando acesso externo. Após tornar o preview público, scripts de teste (por exemplo, Playwright rodando localmente) podem navegar até esse URL e interagir com a aplicação completa. Lembre que essa URL é temporária (ativas apenas enquanto a workspace está ativa)
firebase.blog
.
Configuração do .idx/dev.nix: Se você for rodar testes E2E (Playwright) no ambiente Nix do Firebase Studio, adicione o Chromium no seu .idx/dev.nix. Exemplo de configuração:
{pkgs, ...}: {
  channel = "stable-24.05";
  packages = [
    pkgs.chromium
    # ... outros pacotes necessários (nodejs, python, etc.) ...
  ];
  env = {
    CHROME_BIN = "/usr/bin/chromium";
    # PATH é gerenciado automaticamente, mas outros vars podem ser definidos aqui
  };
}
Isso garante que o Chromium esteja instalado na VM e que a variável CHROME_BIN aponte para o binário, permitindo que o Playwright o utilize
firebase.google.com
firebase.google.com
. Sem essa configuração, o Playwright pode não encontrar um navegador.
Make Preview Public e Portas Públicas: Além do front-end, o Firebase Studio permite liberar portas de backend (por exemplo, porta 3000 do Node) para acesso público
firebase.blog
. Isso é útil para integrar frontend e backend sem alterar o código (basta apontar o front-end para a URL pública do backend). O botão de cadeado no painel de “Backend Ports” abre a porta, e o front-end pode consumi-la pela URL fornecida
firebase.blog
. Contudo, lembre-se que essas portas públicas são temporárias e apenas para desenvolvimento/teste, não substituem uma deployment de produção.
### 7. Organização da Suíte de Testes
Estrutura de Pastas: Separe os testes por tipo. Por exemplo:
/tests
  /unit         # testes unitários
  /integration  # testes de API/integração
  /e2e          # testes end-to-end
Ou coloque tests ao lado dos arquivos de código. Mantenha fixtures em pastas dedicadas (/tests/fixtures) e evite duplicação de dados.
Nomenclatura e Configurações: Use convenções como *.test.ts ou *.spec.ts. Caso use Jest/Vitest, crie arquivos de configuração separados (por exemplo, jest.unit.config.js, jest.integration.config.js ou equivalentes para Vitest) para cada contexto. Isso permite, por exemplo, desabilitar a emulação de rede nos unitários e habilitá-la nos integrações.
Scripts de Execução: No package.json, defina scripts para cada categoria:
{
  "scripts": {
    "test:unit": "vitest run --config vitest.unit.config.ts",
    "test:integration": "vitest run --config vitest.integration.config.ts",
    "test:e2e": "playwright test",
    "test": "npm-run-all test:unit test:integration test:e2e"
  }
}
Com esses scripts, o desenvolvedor pode executar apenas um tipo de teste (ex.: npm run test:unit) ou todos em sequência (npm test). Ajuste conforme seu runner: para Jest, por exemplo, use flags em cada config específica.
Integração Contínua (CI): Configure seu pipeline (ex.: GitHub Actions) para instalar dependências, iniciar o banco de testes e rodar todas as suites. Exemplo de trecho de workflow YAML com MySQL:
jobs:
  tests:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: root
        ports:
          - 3306:3306
    env:
      NODE_ENV: test
      DATABASE_URL: mysql://root:root@localhost:3306/leiloes_test
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npx prisma migrate deploy
      - run: npm test
Isso executa todas as etapas de teste em um ambiente isolado. A pirâmide de testes orienta a ter muitos testes unitários (base) e poucos E2E (topo)
apidog.com
. Em CI, você pode marcar falhas ao primeiro erro e, ao final, gerar relatórios de cobertura.
Ambiente de Staging: Para testes mais realistas, tenha um ambiente de staging (pré-produção) deployado. Executar testes de smoke e integrações contínuas no staging (por ex., via Cypress/Playwright) antes da release aumenta a confiabilidade.
### 8. Ferramentas e Recursos Adicionais
Validação e Emulação Firebase: Como estamos na suíte Firebase Studio, lembre-se dos Emuladores Firebase (Autenticação, Firestore, etc.) incorporados no Firebase CLI. Você pode executar testes unitários ou integração que precisam desses serviços emulados.
Documentação Oficial: Consulte sempre a documentação oficial do Firebase Studio e do Nix dev.nix
firebase.google.com
 para detalhes sobre ambiente. O blog do Firebase (como o artigo “Simplify development with public ports in Firebase Studio”
firebase.blog
firebase.blog
) traz dicas atualizadas sobre funcionalidade de preview e portas públicas.
Resumo: O objetivo é garantir cobertura completa das funcionalidades de leilão em todas as camadas de teste. Use testes unitários para lógica pura, integração para fluxo servidor/BD e E2E para fluxos críticos. Mantenha schemas Prisma/MySQL e Zod sincronizados via migrations e geradores automáticos
github.com
. Adote boas ferramentas (Vitest/Jest, Supertest, Playwright, zod-fixture) e uma infraestrutura de teste sólida (banco isolado, CI, staging). Assim, o desenvolvedor terá orientações claras e exemplos concretos para implementar imediatamente a estratégia de testes.

```
- README.md:
```md
# BidExpert - Powered by Firebase Studio

This is a Next.js starter application built with Firebase Studio. It's designed to provide a robust foundation for an online auction platform, complete with an admin panel, user authentication, and a flexible data layer.

To get started, take a look at `src/app/page.tsx`.

---

## Architectural Overview

This application follows a robust **MVC (Model-View-Controller) with a Service Layer** architecture to ensure scalability and maintainability. This layered approach ensures a clear separation of concerns, making the codebase easier to understand, test, and extend.

-   **Model:** Managed by **Prisma ORM**, with the schema defined in `prisma/schema.prisma`. This defines the shape of our data.
-   **Views:** Implemented using **Next.js with React Server Components** (`.tsx` files). This is the UI the user interacts with.
-   **Controllers:** Handled by **Next.js Server Actions** (`/actions.ts` files). These orchestrate calls to the service layer in response to user interactions.
-   **Services:** Contain the core business logic (`/services/*.ts` files), decoupled from both the database and the controllers.
-   **Repositories:** Encapsulate all database queries using the Prisma Client, providing a clean data access layer.

---

## Database Setup

This project uses **Prisma ORM** as its data access layer, allowing for flexible interaction with **PostgreSQL**, **MySQL**, or **Firestore**. The active database is determined by the `DATABASE_URL` and `NEXT_PUBLIC_ACTIVE_DATABASE_SYSTEM` environment variables.

### 1. Environment Setup

-   For **MySQL (Default for this project)**: Ensure your MySQL server is running. Set the following in your `.env` file with your database credentials.
    ```
    # Example for MySQL
    NEXT_PUBLIC_ACTIVE_DATABASE_SYSTEM=MYSQL
    DATABASE_URL="mysql://USER:PASSWORD@HOST:PORT/DATABASE"
    ```
-   For **PostgreSQL**: Set up your database and provide the connection string in your `.env` file. Change the `provider` in `prisma/schema.prisma` to `postgresql`.
    ```
    # Example for PostgreSQL
    NEXT_PUBLIC_ACTIVE_DATABASE_SYSTEM=POSTGRES
    DATABASE_URL="postgresql://USER:PASSWORD@HOST:PORT/DATABASE"
    ```

### 2. Database Initialization & Seeding

When using a fresh database, you need to create the necessary tables/collections and populate essential data.

-   **`npx prisma db push` (For SQL Databases):** If using MySQL or PostgreSQL, run this command **once** to sync your Prisma schema with the database. This command is included in the `npm run dev` script, so it will run automatically on startup.
    ```bash
    npx prisma db push
    ```
-   **`npm run dev`**: The first time you run the development server, it will automatically execute an initialization script (`init-db.ts`). This script populates **essential data only** (like Roles, Categories, States, etc.). This step is required for the application to start correctly.

-   **`npm run db:seed`**: After the server has started at least once, you can run this script manually in your terminal to populate the database with a **full set of sample data** (auctions, lots, users, etc.). Use this to get a fully populated environment for development and demonstration. The script checks for existing data to prevent duplication.

```bash
# First, run the development server. This will initialize the database with essential data.
npm run dev

# (In a new terminal, while the server is running)
# Then, populate with the full sample data set.
npm run db:seed
```

Your selected database is now ready to use with the application.
---

## Estratégia de Testes para Aplicação de Leilões Full-Stack
### 1. Camadas e Tipos de Teste
Testes Unitários: Validam pequenas unidades de código isoladamente (funções, métodos, validações). São rápidos e não dependem de banco de dados ou rede, focando apenas na lógica interna. Por exemplo, testar uma função que calcula o próximo lance válido ou valida se um campo obrigatório está presente. Esse tipo de teste “isola a lógica garantindo que cada unidade funcione como esperado”
mendoncadev.com.br
.
Testes de Integração: Verificam a interação entre componentes ou módulos, incluindo acesso a banco de dados ou APIs externas. Por exemplo, testar um endpoint REST de cadastro de usuário usando um servidor Express e um banco MySQL real via Docker. Isso garante que controladores, serviços e camada de dados estão integrados corretamente. Os testes de integração “garantem que módulos e componentes do sistema funcionem corretamente juntos”
mendoncadev.com.br
.
Testes End-to-End (E2E): Simulam fluxos completos do usuário final, exercitando toda a pilha (front-end, back-end, banco de dados, etc.). Por exemplo, um teste E2E pode abrir a interface web do leilão, registrar um usuário, habilitá-lo, efetuar lances válidos/inválidos e gerar relatórios, tudo via UI ou API. Os testes E2E “verificam a funcionalidade completa do aplicativo do início ao fim, simulando cenários reais de usuários”
apidog.com
. Eles são mais lentos e devem focar em jornadas críticas (p. ex. finalização de leilão), deixando os detalhes menores para testes unitários.
### 2. Consistência de Schemas
Para evitar divergências entre o banco de dados, o schema do Prisma e os esquemas Zod:
Migrations e Versionamento: Sempre use Prisma Migrate para controlar alterações do schema MySQL. Toda modificação no model do Prisma deve ser migrada ao banco (via prisma migrate), garantindo que o BD real reflita o schema Prisma.
Geradores Automáticos: Utilize geradores que sincronizam Zod e Prisma. Por exemplo, o zod-prisma cria automaticamente esquemas Zod baseados no modelo Prisma, evitando ter que manter manualmente cada mudança de schema
github.com
. Bibliotecas NPM como prisma-zod-generator ou zod-prisma geram código Zod a partir do modelo, mantendo-os 1:1.
Validações Automatizadas: Além do tsc (TypeScript) que já aponta inconsistências de tipo, considere testes que carreguem os esquemas Zod gerados e comparem contra a saída do banco. Ferramentas como zod-fixture geram fixtures de teste a partir de esquemas Zod
github.com
, ajudando a validar entradas/saídas. Outra prática é escrever testes que tentem gravar entradas inválidas (segundo o Zod) no BD, confirmando que o middleware de validação bloqueia o acesso indevido. Dessa forma, o schema Zod (API) e o schema Prisma (BD) permanecem alinhados.
### 3. Cobertura de Funcionalidades do Leilão
Teste todos os fluxos principais da aplicação de leilões:
Cadastro e Habilitação: Teste unitário para validar regras de formato de dados de cadastro. Testes de integração via API para verificar que /api/usuarios cria o usuário no banco e que háflows como envio de e-mail ou notificações. Por exemplo, com Supertest pode-se validar que POST /api/usuarios retorna 201 e corpo JSON contendo o ID gerado.
Lances Válidos/Inválidos: Em lógica de negócios, escreva testes unitários para regras de lance (p. ex. “um lance deve ser maior que o último lance válido ou seguir incremento mínimo”). Em testes de integração, faça chamadas ao endpoint de lances (ex.: POST /api/lances) inserindo dados válidos e inválidos, verificando códigos de resposta e mensagens de erro. Por exemplo:
import request from 'supertest';
import { app } from '../src/app';

describe('POST /api/lances', () => {
  it('deve rejeitar lance abaixo do mínimo', async () => {
    const res = await request(app)
      .post('/api/lances')
      .send({ valor: 0.50, loteId: 'abc123', usuarioId: 1 });
    expect(res.status).toBe(400);
    expect(res.body).toHaveProperty('erro');
  });
});
Encerramento de Leilão: Teste a rotina que encerra o leilão (cron job ou função manual). Por exemplo, ao simular o fim do prazo, verificar que o status do leilão passa para “encerrado” e um vencedor é definido. Escreva testes de integração para endpoints de finalização ou simulação de tempo, garantindo atualização correta do BD.
Geração de Relatórios: Se a aplicação gera relatórios (por exemplo, somatório de lances ou visitas por leilão), crie testes que insiram dados no BD e consultem a API de relatório, verificando consistência dos valores agregados. Teste queries complexas no banco usando fixtures de dados.
Consultas com Joins Complexos: Para funcionalidades que exibem dados combinados (p. ex. cards de visitação que mostram Leilão + Lote + Comitente + Lances + Visitas), escreva testes de integração/prisma que gerem registros de cada entidade e consultem via Prisma com include ou join. Por exemplo:
const visita = await prisma.visita.findFirst({
  include: { leilao: true, lote: true, comitente: true, lances: true }
});
expect(visita).toMatchObject({
  leilao: { /* dados do leilão esperado */ },
  lote: { /* dados do lote */ },
  comitente: { /* dados do comitente */ },
  lances: expect.any(Array)
});
Isso garante que a consulta traga todas as relações corretas. Em testes E2E, valide também a interface (front-end) exibindo corretamente esses dados complexos.
### 4. Estratégia de Banco de Testes
Banco Real Isolado: Use uma instância MySQL separada (via Docker) para os testes. Um container mysql:8 isolado evita interferir nos dados de desenvolvimento. Configure o .env.test ou variável DATABASE_URL apontando para esse DB de teste. Em CI, você pode usar serviços do GitHub Actions ou Docker Compose para provisionar o MySQL antes dos testes.
Setup/Reset: Antes da suíte de testes, aplique as migrações: por exemplo, npx prisma migrate deploy ou prisma migrate reset --force. Entre cada teste (ou suíte), limpe o estado do banco – isso pode ser feito via transações que são revertidas (jdbc), truncando tabelas ou recriando o banco entre suites. Em frameworks como Jest/Vitest, use hooks beforeAll e afterAll para inicializar e limpar. Garantir que cada teste comece de um estado conhecido elimina efeitos colaterais.
Ambiente de Teste Separado: Utilize variáveis de ambiente para diferenciar ambiente de teste. Por exemplo, NODE_ENV=test ou DATABASE_URL distinta. Isso evita rodar testes em bases de dados de produção ou desenvolvimento. No código de inicialização do app, carregue o .env.test quando apropriado. Além disso, prefira configurações específicas de teste (sem portas em uso, logs reduzidos) para manter a performance do pipeline.
### 5. Ferramentas Recomendadas
Test Runner (Unit/Integração): Vitest e Jest são os mais usados. O Vitest é um runner moderno que funciona muito bem com projetos Vite/Next.js e TypeScript. Ele oferece API compatível com Jest e destacável foco em velocidade (“Vite significa rápido” – muitas vezes executa testes diversas vezes mais rápido que Jest)
saucelabs.com
. Jest é maduro, amplamente suportado e não exige configuração extra para projetos comuns. Em geral, Vitest tende a ser recomendado para projetos com Vite ou Next.js modernos devido à performance, enquanto Jest é sólido se você já o conhece ou precisa de recursos avançados como snapshot testing.
Simulação de APIs (Integração): Supertest é excelente para testar endpoints HTTP em aplicações Express/Koa/etc
mendoncadev.com.br
. Ele permite emitir requisições (GET, POST, etc.) diretamente contra o servidor em memória. Use-o para testes de integração REST. Outra opção é Axios combinado com um servidor local ou nock para simular respostas de serviços externos.
Validação de Dados: Para criar dados de teste consistentes a partir de esquemas, use zod-fixture, que “cria fixtures de teste baseados em um schema Zod”
github.com
. Com ele você evita criar manualmente objetos de teste. Também considere bibliotecas como faker.js para dados randômicos e Prisma Factory (npm) para construir entidades completas.
Testes End-to-End: Playwright (Microsoft) é uma ferramenta robusta de E2E que suporta múltiplos navegadores e linguagens. Ao contrário do Cypress (que roda dentro do navegador e é limitado a JS/TS), o Playwright roda fora e oferece suporte a diversos navegadores e paralelismo embutido
checklyhq.com
. O Cypress tem ótima experiência de uso e depuração integrada, mas não suporta Safari nem múltiplas abas, e o paralelismo requer serviço pago. Recomenda-se Playwright para testes E2E amplos (ex.: fluxos completos de usuário) e Cypress se focar em testes front-end JS/TS com feedback interativo.
Outras Ferramentas: Para teste de front-end React, use Testing Library (React Testing Library) ou Vitest com JSDOM para componentes UI isolados. Para bancos em memória, considere SQLite in-memory ou Prisma DSN especial. Ferramentas de CI de testes (como Coveralls) podem ser integradas posteriormente, mas foque primeiro na cobertura de funcionalidades.
### 6. Integração com Firebase Studio
Prototyper de IA (App Prototyping Agent): O Firebase Studio inclui um agente de prototipagem por IA (chamado Prototyper ou App Prototyping agent) que gera automaticamente código de aplicação full-stack a partir de prompts multimodais
firebase.google.com
. Ao descrever a ideia da app em linguagem natural, o agente cria um “blueprint”, o código-fonte correspondente e um preview da aplicação. Esse código gerado é injetado diretamente no workspace (IDE VSCode) do Firebase Studio, permitindo que o desenvolvedor revise ou modifique imediatamente no ambiente de código. Em outras palavras, o desenvolvedor trabalha no VSCode web do Firebase Studio e o Prototyper populos generationa arquivos editáveis nesse mesmo editor
firebase.google.com
.
Testando o Preview (VM Fechada): O preview da aplicação no Firebase Studio roda numa VM isolada. Para testar via scripts externos (Playwright, etc.), use a funcionalidade “Make Preview Public”. No próprio Firebase Studio, abra o preview web e clique em “Make Preview Public” na toolbar
firebase.blog
. Isso libera um URL externo (indicado por um ícone de globo amarelo) que qualquer máquina pode acessar temporariamente. A figura abaixo mostra como fica o painel de portas e o botão de pré-visualização pública: Figura: No Firebase Studio, abra o painel “Backend Ports” (Ctrl+',' → “Backend Ports”) e clique no cadeado para liberar a porta do backend publicamente
firebase.blog
. Uma vez liberada, aparece o ícone de globo que indica URL público. Figura: Na aba de preview web do Firebase Studio, clique em “Make Preview Public” (ícone de cadeado) para obter um link público da aplicação
firebase.blog
. O ícone muda para globo amarelo, sinalizando acesso externo. Após tornar o preview público, scripts de teste (por exemplo, Playwright rodando localmente) podem navegar até esse URL e interagir com a aplicação completa. Lembre que essa URL é temporária (ativas apenas enquanto a workspace está ativa)
firebase.blog
.
Configuração do .idx/dev.nix: Se você for rodar testes E2E (Playwright) no ambiente Nix do Firebase Studio, adicione o Chromium no seu .idx/dev.nix. Exemplo de configuração:
{pkgs, ...}: {
  channel = "stable-24.05";
  packages = [
    pkgs.chromium
    # ... outros pacotes necessários (nodejs, python, etc.) ...
  ];
  env = {
    CHROME_BIN = "/usr/bin/chromium";
    # PATH é gerenciado automaticamente, mas outros vars podem ser definidos aqui
  };
}
Isso garante que o Chromium esteja instalado na VM e que a variável CHROME_BIN aponte para o binário, permitindo que o Playwright o utilize
firebase.google.com
firebase.google.com
. Sem essa configuração, o Playwright pode não encontrar um navegador.
Make Preview Public e Portas Públicas: Além do front-end, o Firebase Studio permite liberar portas de backend (por exemplo, porta 3000 do Node) para acesso público
firebase.blog
. Isso é útil para integrar frontend e backend sem alterar o código (basta apontar o front-end para a URL pública do backend). O botão de cadeado no painel de “Backend Ports” abre a porta, e o front-end pode consumi-la pela URL fornecida
firebase.blog
. Contudo, lembre-se que essas portas públicas são temporárias e apenas para desenvolvimento/teste, não substituem uma deployment de produção.
### 7. Organização da Suíte de Testes
Estrutura de Pastas: Separe os testes por tipo. Por exemplo:
/tests
  /unit         # testes unitários
  /integration  # testes de API/integração
  /e2e          # testes end-to-end
Ou coloque tests ao lado dos arquivos de código. Mantenha fixtures em pastas dedicadas (/tests/fixtures) e evite duplicação de dados.
Nomenclatura e Configurações: Use convenções como *.test.ts ou *.spec.ts. Caso use Jest/Vitest, crie arquivos de configuração separados (por exemplo, jest.unit.config.js, jest.integration.config.js ou equivalentes para Vitest) para cada contexto. Isso permite, por exemplo, desabilitar a emulação de rede nos unitários e habilitá-la nos integrações.
Scripts de Execução: No package.json, defina scripts para cada categoria:
{
  "scripts": {
    "test:unit": "vitest run --config vitest.unit.config.ts",
    "test:integration": "vitest run --config vitest.integration.config.ts",
    "test:e2e": "playwright test",
    "test": "npm-run-all test:unit test:integration test:e2e"
  }
}
Com esses scripts, o desenvolvedor pode executar apenas um tipo de teste (ex.: npm run test:unit) ou todos em sequência (npm test). Ajuste conforme seu runner: para Jest, por exemplo, use flags em cada config específica.
Integração Contínua (CI): Configure seu pipeline (ex.: GitHub Actions) para instalar dependências, iniciar o banco de testes e rodar todas as suites. Exemplo de trecho de workflow YAML com MySQL:
jobs:
  tests:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: root
        ports:
          - 3306:3306
    env:
      NODE_ENV: test
      DATABASE_URL: mysql://root:root@localhost:3306/leiloes_test
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npx prisma migrate deploy
      - run: npm test
Isso executa todas as etapas de teste em um ambiente isolado. A pirâmide de testes orienta a ter muitos testes unitários (base) e poucos E2E (topo)
apidog.com
. Em CI, você pode marcar falhas ao primeiro erro e, ao final, gerar relatórios de cobertura.
Ambiente de Staging: Para testes mais realistas, tenha um ambiente de staging (pré-produção) deployado. Executar testes de smoke e integrações contínuas no staging (por ex., via Cypress/Playwright) antes da release aumenta a confiabilidade.
### 8. Ferramentas e Recursos Adicionais
Validação e Emulação Firebase: Como estamos na suíte Firebase Studio, lembre-se dos Emuladores Firebase (Autenticação, Firestore, etc.) incorporados no Firebase CLI. Você pode executar testes unitários ou integração que precisam desses serviços emulados.
Documentação Oficial: Consulte sempre a documentação oficial do Firebase Studio e do Nix dev.nix
firebase.google.com
 para detalhes sobre ambiente. O blog do Firebase (como o artigo “Simplify development with public ports in Firebase Studio”
firebase.blog
firebase.blog
) traz dicas atualizadas sobre funcionalidade de preview e portas públicas.
Resumo: O objetivo é garantir cobertura completa das funcionalidades de leilão em todas as camadas de teste. Use testes unitários para lógica pura, integração para fluxo servidor/BD e E2E para fluxos críticos. Mantenha schemas Prisma/MySQL e Zod sincronizados via migrations e geradores automáticos
github.com
. Adote boas ferramentas (Vitest/Jest, Supertest, Playwright, zod-fixture) e uma infraestrutura de teste sólida (banco isolado, CI, staging). Assim, o desenvolvedor terá orientações claras e exemplos concretos para implementar imediatamente a estratégia de testes.

```
- airules.MD:
```MD
# AI Prototyper Rules

This document contains specific rules and guidelines for the AI prototyper to follow during development.

## 1. Human Authorization and Non-Regression Principle

**Rule:** Any deletion of functionality, components, or significant project alteration **must be explicitly authorized by a human user**. To prevent accidental removal of perfectly functional items while implementing fixes or improvements, the AI must:
1.  Clearly state its intention to delete or refactor a component/file/feature.
2.  Provide a brief justification for why this change is necessary.
3.  Ask for explicit confirmation from the user before proceeding with generating the changes.

**Rationale:** This principle ensures that the development process is always moving forward and prevents regressions. It maintains a safeguard where the human developer has the final say on any destructive or large-scale changes, preserving the stability and integrity of the project.

## 2. Database and Data Source Architecture

**Rule:** The application uses **Prisma ORM** as its exclusive data access layer. Direct use of database drivers is forbidden. All data access logic must be encapsulated within `Repository` classes (e.g., `src/repositories/seller.repository.ts`).

**Rationale:** Using Prisma as the single source of truth for database interactions provides type safety, simplifies queries, and allows the application to seamlessly switch between different SQL databases (MySQL, PostgreSQL) by only changing the `provider` in the `schema.prisma` file and the `DATABASE_URL` in the `.env` file. This eliminates the need for manual database adapters.

## 3. Schema and Migrations

**Rule:** The single source of truth for the database schema is `prisma/schema.prisma`. Any necessary schema changes must be made in this file. During development, the schema should be synchronized with the database by running `npm run db:push`, which is part of the `npm run dev` script.

**Rationale:** Using Prisma as the schema definition tool ensures type safety and provides a consistent way to manage the database structure across different SQL environments.

## 4. MVC with Service Layer Architecture

**Rule:** The application's architecture is strictly defined as **Model-View-Controller (MVC) with an intermediate Service Layer and a Repository Layer**. This structure is the standard for all new development.
- **Controllers** (Server Actions in `actions.ts` files) handle user input and API requests. They are responsible for orchestrating calls to the service layer.
- **Services** (`/services/*.ts`) contain the core business logic, orchestrating calls to one or more repositories and other services. They are decoupled from both the database and the controllers.
- **Repositories** (`/repositories/*.ts`) encapsulate all database queries using the **Prisma Client**. They are the only layer allowed to directly interact with the database.
- **Data Access:** Direct use of `PrismaClient` in services or controllers is forbidden. All database interactions must go through a `Repository`.

**Rationale:** Maintaining a consistent, layered architecture is crucial for the long-term scalability, maintainability, and testability of the project. This separation of concerns (Presentation, Business Logic, Data Access) makes the codebase cleaner and easier to manage.

## 5. Directory Structure

**Rule:** The Next.js application structure must follow the `src` directory convention. The main application routes must reside within `src/app`. **Under no circumstances should a nested `app` directory (e.g., `src/app/app`) or a root-level `app` directory be created.** Any such occurrence must be identified and corrected immediately by merging the files into `src/app` and removing the incorrect directory.

**Rationale:** A nested or misplaced `app` directory breaks Next.js's file-based routing system, leading to build failures and runtime errors. Maintaining the correct structure is critical for the application's stability.

## 6. Code Quality and Naming Conventions

### 6.1. Form Component Standardization

**Rule:** For all CRUD forms, any field representing a foreign key relationship (e.g., selecting a `seller` for an `auction`) **must** use the custom `EntitySelector` component. This component provides a standardized and enhanced user experience including search, on-the-fly creation, editing, and list refreshing. Direct use of a standard `<Select>` component for entity relationships is disallowed.

**Rationale:** This ensures a consistent, powerful, and user-friendly interface across the entire admin panel, reducing development time for new forms and improving the end-user workflow by preventing the need to navigate away to create prerequisite entities.

### 6.2. JavaScript/TypeScript Naming

**Rule:** All new or modified functions, variables, and components must have names that are descriptive, human-readable, and contextually relevant, preferably in Portuguese (e.g., `buscarLeiloes`, `SalvarComitenteButton`). This practice applies to all parts of the codebase, from front-end components to back-end services.

**Rationale:** Clear and consistent naming is fundamental for code quality, making the application easier to read, debug, and maintain for all developers involved, including AI assistants.

### 6.3. HTML Element Identification

**Rule:** All new HTML elements created must have a `data-ai-id` attribute with a unique, human-readable, and contextually relevant name. This name should reflect the element's purpose or content. For example, a button to submit a login form should be `<Button data-ai-id="login-submit-button">`, and a container for a user's profile card should be `<div data-ai-id="user-profile-card">`.

**Rationale:** This convention is essential for the AI to reliably identify and manipulate specific UI elements, ensuring that future requests are executed precisely. It also aids in end-to-end testing and debugging.

## 7. Next.js & React Best Practices

-   **Default to Server Components:** Components should be Server Components by default. Only use the `'use client'` directive when client-side interactivity (hooks like `useState`, `useEffect`, event listeners) is absolutely necessary. This reduces the amount of JavaScript sent to the client, improving performance.
-   **Server Actions for Mutations:** All data mutations (create, update, delete) must be handled through Next.js Server Actions. This simplifies the architecture by eliminating the need for separate API routes and provides a secure, built-in mechanism for form submissions and data handling.
-   **Image Optimization:** Always use the built-in `next/image` component for displaying images. It provides automatic optimization, resizing, and lazy loading, which are crucial for performance.
-   **Memoization:** In client components, use `useMemo` to memoize the results of expensive calculations and `useCallback` to memoize functions passed to child components. This prevents unnecessary re-renders and improves UI responsiveness.
-   **Error Handling:** Implement `error.js` files at appropriate route segments to handle runtime errors gracefully and prevent the entire application from crashing.
-   **Type Safety:** Utilize TypeScript's `import type` for type-only imports to improve build performance and maintain clear separation between type information and runtime code.
-   **Valid Link Hrefs:** Never allow the `href` prop of a Next.js `<Link>` component to be `undefined`. If a link's path is dynamic (e.g., from an API response or props), always validate it before rendering. Provide a fallback href like `/` or `#`, or conditionally render the `<Link>` only when the `href` is valid.

## 8. Development Environment Information

**Rule:** During development (`NODE_ENV === 'development'`), the application footer must display key environment information. This includes the currently active database system (e.g., MySQL, PostgreSQL), the logged-in user's email, and the active Firebase Project ID.

**Rationale:** This provides immediate, persistent context about the development environment, preventing confusion and aiding in debugging database or user-specific issues.

## 9. BidExpertOkrs: Análise Estratégica, KPIs e Insights

**Rule:** All entity management sections (CRUDs) must evolve into comprehensive management and analysis modules, providing strategic insights beyond simple data display. This includes:

-   **Dashboards de Análise Agregada:** Cada menu de entidade principal (e.g., "Leilões", "Comitentes", "Cidades") deve conter um sub-menu de "Análise" (e.g., `/admin/auctions/analysis`) que apresenta KPIs agregados, gráficos comparativos e métricas de performance para o grupo de entidades.
-   **Dashboards de Análise Individual:** A página de detalhe/edição de cada registro (`/admin/[entity]/{id}/edit`) deve incluir uma seção de dashboard exibindo KPIs históricos e métricas de desempenho específicas para aquele registro.
-   **Análise de Dados Aprofundada:** As análises devem, sempre que possível, ir além das contagens básicas. O objetivo é cruzar dados para identificar tendências, padrões e oportunidades (leading indicators). Isso inclui:
    -   **Análise Geográfica:** Mapear performance por cidade, estado e, futuramente, por região (Norte, Sudeste, etc.). A longo prazo, planejar a integração com dados demográficos e econômicos externos (ex: IBGE) para enriquecer os insights.
    -   **Análise Comportamental:** Cruzar dados de leilões com perfis de usuários para entender padrões de lances e preferências.
-   **Fonte de Dados Dinâmica:** Todos os dados dos dashboards devem ser derivados de queries diretas ao banco de dados da aplicação (via Prisma). O uso de dados estáticos ou de exemplo é estritamente proibido para estes componentes.
-   **Insights com IA (Genkit):** Os dashboards devem progressivamente incorporar uma seção para análises e recomendações inteligentes geradas pelo Genkit. A IA deve interpretar os dados apresentados (KPIs, gráficos) e fornecer insights textuais, apontando oportunidades, gargalos e recomendações estratégicas para a diretoria.

**Rationale:** Esta estratégia transforma o painel de administração de uma ferramenta de entrada de dados em um poderoso centro de Business Intelligence (BI) e suporte à decisão. Ela habilita a gestão baseada em dados, o monitoramento de OKRs, a identificação de oportunidades estratégicas e o alinhamento de toda a empresa em torno de objetivos mensuráveis.

## 10. Gerenciamento de Dependências

**Rule:** Para manter o projeto otimizado e evitar o crescimento excessivo do diretório `node_modules` e dos pacotes de produção, siga estas diretrizes:
-   **Dependências de Desenvolvimento:** Pacotes usados exclusivamente para desenvolvimento, teste ou processos de build (e.g., `@playwright/test`, `puppeteer` para geração de PDF no servidor) **devem** ser instalados como `devDependencies`. Isso impede que eles sejam incluídos no build de produção.
-   **Análise de Pacotes Pesados:** Antes de adicionar uma nova dependência, especialmente para funcionalidades não essenciais, avalie seu tamanho e impacto. Use ferramentas como `cost-of-modules` ou `du` para identificar os pacotes mais pesados.
-   **Alternativas Leves:** Para funcionalidades como geração de PDF ou manipulação de imagens, considere alternativas mais leves ou serviços externos em vez de pacotes pesados como o `puppeteer` completo, se possível.
-   **Revisão Periódica:** Revise periodicamente o `package.json` para remover dependências não utilizadas ou desnecessárias.

**Rationale:** Um `node_modules` grande e pacotes de produção inchados podem levar a tempos de instalação mais longos, builds mais lentos e custos de hospedagem mais altos. Manter as dependências limpas e otimizadas é crucial para a saúde do projeto.

## 11. Estratégia de Testes para Aplicação de Leilões Full-Stack
### 1. Camadas e Tipos de Teste
Testes Unitários: Validam pequenas unidades de código isoladamente (funções, métodos, validações). São rápidos e não dependem de banco de dados ou rede, focando apenas na lógica interna. Por exemplo, testar uma função que calcula o próximo lance válido ou valida se um campo obrigatório está presente. Esse tipo de teste “isola a lógica garantindo que cada unidade funcione como esperado”
mendoncadev.com.br
.
Testes de Integração: Verificam a interação entre componentes ou módulos, incluindo acesso a banco de dados ou APIs externas. Por exemplo, testar um endpoint REST de cadastro de usuário usando um servidor Express e um banco MySQL real via Docker. Isso garante que controladores, serviços e camada de dados estão integrados corretamente. Os testes de integração “garantem que módulos e componentes do sistema funcionem corretamente juntos”
mendoncadev.com.br
.
Testes End-to-End (E2E): Simulam fluxos completos do usuário final, exercitando toda a pilha (front-end, back-end, banco de dados, etc.). Por exemplo, um teste E2E pode abrir a interface web do leilão, registrar um usuário, habilitá-lo, efetuar lances válidos/inválidos e gerar relatórios, tudo via UI ou API. Os testes E2E “verificam a funcionalidade completa do aplicativo do início ao fim, simulando cenários reais de usuários”
apidog.com
. Eles são mais lentos e devem focar em jornadas críticas (p. ex. finalização de leilão), deixando os detalhes menores para testes unitários.
### 2. Consistência de Schemas
Para evitar divergências entre o banco de dados, o schema do Prisma e os esquemas Zod:
Migrations e Versionamento: Sempre use Prisma Migrate para controlar alterações do schema MySQL. Toda modificação no model do Prisma deve ser migrada ao banco (via prisma migrate), garantindo que o BD real reflita o schema Prisma.
Geradores Automáticos: Utilize geradores que sincronizam Zod e Prisma. Por exemplo, o zod-prisma cria automaticamente esquemas Zod baseados no modelo Prisma, evitando ter que manter manualmente cada mudança de schema
github.com
. Bibliotecas NPM como prisma-zod-generator ou zod-prisma geram código Zod a partir do modelo, mantendo-os 1:1.
Validações Automatizadas: Além do tsc (TypeScript) que já aponta inconsistências de tipo, considere testes que carreguem os esquemas Zod gerados e comparem contra a saída do banco. Ferramentas como zod-fixture geram fixtures de teste a partir de esquemas Zod
github.com
, ajudando a validar entradas/saídas. Outra prática é escrever testes que tentem gravar entradas inválidas (segundo o Zod) no BD, confirmando que o middleware de validação bloqueia o acesso indevido. Dessa forma, o schema Zod (API) e o schema Prisma (BD) permanecem alinhados.
### 3. Cobertura de Funcionalidades do Leilão
Teste todos os fluxos principais da aplicação de leilões:
Cadastro e Habilitação: Teste unitário para validar regras de formato de dados de cadastro. Testes de integração via API para verificar que /api/usuarios cria o usuário no banco e que háflows como envio de e-mail ou notificações. Por exemplo, com Supertest pode-se validar que POST /api/usuarios retorna 201 e corpo JSON contendo o ID gerado.
Lances Válidos/Inválidos: Em lógica de negócios, escreva testes unitários para regras de lance (p. ex. “um lance deve ser maior que o último lance válido ou seguir incremento mínimo”). Em testes de integração, faça chamadas ao endpoint de lances (ex.: POST /api/lances) inserindo dados válidos e inválidos, verificando códigos de resposta e mensagens de erro. Por exemplo:
import request from 'supertest';
import { app } from '../src/app';

describe('POST /api/lances', () => {
  it('deve rejeitar lance abaixo do mínimo', async () => {
    const res = await request(app)
      .post('/api/lances')
      .send({ valor: 0.50, loteId: 'abc123', usuarioId: 1 });
    expect(res.status).toBe(400);
    expect(res.body).toHaveProperty('erro');
  });
});
Encerramento de Leilão: Teste a rotina que encerra o leilão (cron job ou função manual). Por exemplo, ao simular o fim do prazo, verificar que o status do leilão passa para “encerrado” e um vencedor é definido. Escreva testes de integração para endpoints de finalização ou simulação de tempo, garantindo atualização correta do BD.
Geração de Relatórios: Se a aplicação gera relatórios (por exemplo, somatório de lances ou visitas por leilão), crie testes que insiram dados no BD e consultem a API de relatório, verificando consistência dos valores agregados. Teste queries complexas no banco usando fixtures de dados.
Consultas com Joins Complexos: Para funcionalidades que exibem dados combinados (p. ex. cards de visitação que mostram Leilão + Lote + Comitente + Lances + Visitas), escreva testes de integração/prisma que gerem registros de cada entidade e consultem via Prisma com include ou join. Por exemplo:
const visita = await prisma.visita.findFirst({
  include: { leilao: true, lote: true, comitente: true, lances: true }
});
expect(visita).toMatchObject({
  leilao: { /* dados do leilão esperado */ },
  lote: { /* dados do lote */ },
  comitente: { /* dados do comitente */ },
  lances: expect.any(Array)
});
Isso garante que a consulta traga todas as relações corretas. Em testes E2E, valide também a interface (front-end) exibindo corretamente esses dados complexos.
### 4. Estratégia de Banco de Testes
Banco Real Isolado: Use uma instância MySQL separada (via Docker) para os testes. Um container mysql:8 isolado evita interferir nos dados de desenvolvimento. Configure o .env.test ou variável DATABASE_URL apontando para esse DB de teste. Em CI, você pode usar serviços do GitHub Actions ou Docker Compose para provisionar o MySQL antes dos testes.
Setup/Reset: Antes da suíte de testes, aplique as migrações: por exemplo, npx prisma migrate deploy ou prisma migrate reset --force. Entre cada teste (ou suíte), limpe o estado do banco – isso pode ser feito via transações que são revertidas (jdbc), truncando tabelas ou recriando o banco entre suites. Em frameworks como Jest/Vitest, use hooks beforeAll e afterAll para inicializar e limpar. Garantir que cada teste comece de um estado conhecido elimina efeitos colaterais.
Ambiente de Teste Separado: Utilize variáveis de ambiente para diferenciar ambiente de teste. Por exemplo, NODE_ENV=test ou DATABASE_URL distinta. Isso evita rodar testes em bases de dados de produção ou desenvolvimento. No código de inicialização do app, carregue o .env.test quando apropriado. Além disso, prefira configurações específicas de teste (sem portas em uso, logs reduzidos) para manter a performance do pipeline.
### 5. Ferramentas Recomendadas
Test Runner (Unit/Integração): Vitest e Jest são os mais usados. O Vitest é um runner moderno que funciona muito bem com projetos Vite/Next.js e TypeScript. Ele oferece API compatível com Jest e destacável foco em velocidade (“Vite significa rápido” – muitas vezes executa testes diversas vezes mais rápido que Jest)
saucelabs.com
. Jest é maduro, amplamente suportado e não exige configuração extra para projetos comuns. Em geral, Vitest tende a ser recomendado para projetos com Vite ou Next.js modernos devido à performance, enquanto Jest é sólido se você já o conhece ou precisa de recursos avançados como snapshot testing.
Simulação de APIs (Integração): Supertest é excelente para testar endpoints HTTP em aplicações Express/Koa/etc
mendoncadev.com.br
. Ele permite emitir requisições (GET, POST, etc.) diretamente contra o servidor em memória. Use-o para testes de integração REST. Outra opção é Axios combinado com um servidor local ou nock para simular respostas de serviços externos.
Validação de Dados: Para criar dados de teste consistentes a partir de esquemas, use zod-fixture, que “cria fixtures de teste baseados em um schema Zod”
github.com
. Com ele você evita criar manualmente objetos de teste. Também considere bibliotecas como faker.js para dados randômicos e Prisma Factory (npm) para construir entidades completas.
Testes End-to-End: Playwright (Microsoft) é uma ferramenta robusta de E2E que suporta múltiplos navegadores e linguagens. Ao contrário do Cypress (que roda dentro do navegador e é limitado a JS/TS), o Playwright roda fora e oferece suporte a diversos navegadores e paralelismo embutido
checklyhq.com
. O Cypress tem ótima experiência de uso e depuração integrada, mas não suporta Safari nem múltiplas abas, e o paralelismo requer serviço pago. Recomenda-se Playwright para testes E2E amplos (ex.: fluxos completos de usuário) e Cypress se focar em testes front-end JS/TS com feedback interativo.
Outras Ferramentas: Para teste de front-end React, use Testing Library (React Testing Library) ou Vitest com JSDOM para componentes UI isolados. Para bancos em memória, considere SQLite in-memory ou Prisma DSN especial. Ferramentas de CI de testes (como Coveralls) podem ser integradas posteriormente, mas foque primeiro na cobertura de funcionalidades.
### 6. Integração com Firebase Studio
Prototyper de IA (App Prototyping Agent): O Firebase Studio inclui um agente de prototipagem por IA (chamado Prototyper ou App Prototyping agent) que gera automaticamente código de aplicação full-stack a partir de prompts multimodais
firebase.google.com
. Ao descrever a ideia da app em linguagem natural, o agente cria um “blueprint”, o código-fonte correspondente e um preview da aplicação. Esse código gerado é injetado diretamente no workspace (IDE VSCode) do Firebase Studio, permitindo que o desenvolvedor revise ou modifique imediatamente no ambiente de código. Em outras palavras, o desenvolvedor trabalha no VSCode web do Firebase Studio e o Prototyper populos generationa arquivos editáveis nesse mesmo editor
firebase.google.com
.
Testando o Preview (VM Fechada): O preview da aplicação no Firebase Studio roda numa VM isolada. Para testar via scripts externos (Playwright, etc.), use a funcionalidade “Make Preview Public”. No próprio Firebase Studio, abra o preview web e clique em “Make Preview Public” na toolbar
firebase.blog
. Isso libera um URL externo (indicado por um ícone de globo amarelo) que qualquer máquina pode acessar temporariamente. A figura abaixo mostra como fica o painel de portas e o botão de pré-visualização pública: Figura: No Firebase Studio, abra o painel “Backend Ports” (Ctrl+',' → “Backend Ports”) e clique no cadeado para liberar a porta do backend publicamente
firebase.blog
. Uma vez liberada, aparece o ícone de globo que indica URL público. Figura: Na aba de preview web do Firebase Studio, clique em “Make Preview Public” (ícone de cadeado) para obter um link público da aplicação
firebase.blog
. O ícone muda para globo amarelo, sinalizando acesso externo. Após tornar o preview público, scripts de teste (por exemplo, Playwright rodando localmente) podem navegar até esse URL e interagir com a aplicação completa. Lembre que essa URL é temporária (ativas apenas enquanto a workspace está ativa)
firebase.blog
.
Configuração do .idx/dev.nix: Se você for rodar testes E2E (Playwright) no ambiente Nix do Firebase Studio, adicione o Chromium no seu .idx/dev.nix. Exemplo de configuração:
{pkgs, ...}: {
  channel = "stable-24.05";
  packages = [
    pkgs.chromium
    # ... outros pacotes necessários (nodejs, python, etc.) ...
  ];
  env = {
    CHROME_BIN = "/usr/bin/chromium";
    # PATH é gerenciado automaticamente, mas outros vars podem ser definidos aqui
  };
}
Isso garante que o Chromium esteja instalado na VM e que a variável CHROME_BIN aponte para o binário, permitindo que o Playwright o utilize
firebase.google.com
firebase.google.com
. Sem essa configuração, o Playwright pode não encontrar um navegador.
Make Preview Public e Portas Públicas: Além do front-end, o Firebase Studio permite liberar portas de backend (por exemplo, porta 3000 do Node) para acesso público
firebase.blog
. Isso é útil para integrar frontend e backend sem alterar o código (basta apontar o front-end para a URL pública do backend). O botão de cadeado no painel de “Backend Ports” abre a porta, e o front-end pode consumi-la pela URL fornecida
firebase.blog
. Contudo, lembre-se que essas portas públicas são temporárias e apenas para desenvolvimento/teste, não substituem uma deployment de produção.
### 7. Organização da Suíte de Testes
Estrutura de Pastas: Separe os testes por tipo. Por exemplo:
/tests
  /unit         # testes unitários
  /integration  # testes de API/integração
  /e2e          # testes end-to-end
Ou coloque tests ao lado dos arquivos de código. Mantenha fixtures em pastas dedicadas (/tests/fixtures) e evite duplicação de dados.
Nomenclatura e Configurações: Use convenções como *.test.ts ou *.spec.ts. Caso use Jest/Vitest, crie arquivos de configuração separados (por exemplo, jest.unit.config.js, jest.integration.config.js ou equivalentes para Vitest) para cada contexto. Isso permite, por exemplo, desabilitar a emulação de rede nos unitários e habilitá-la nos integrações.
Scripts de Execução: No package.json, defina scripts para cada categoria:
{
  "scripts": {
    "test:unit": "vitest run --config vitest.unit.config.ts",
    "test:integration": "vitest run --config vitest.integration.config.ts",
    "test:e2e": "playwright test",
    "test": "npm-run-all test:unit test:integration test:e2e"
  }
}
Com esses scripts, o desenvolvedor pode executar apenas um tipo de teste (ex.: npm run test:unit) ou todos em sequência (npm test). Ajuste conforme seu runner: para Jest, por exemplo, use flags em cada config específica.
Integração Contínua (CI): Configure seu pipeline (ex.: GitHub Actions) para instalar dependências, iniciar o banco de testes e rodar todas as suites. Exemplo de trecho de workflow YAML com MySQL:
jobs:
  tests:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: root
        ports:
          - 3306:3306
    env:
      NODE_ENV: test
      DATABASE_URL: mysql://root:root@localhost:3306/leiloes_test
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npx prisma migrate deploy
      - run: npm test
Isso executa todas as etapas de teste em um ambiente isolado. A pirâmide de testes orienta a ter muitos testes unitários (base) e poucos E2E (topo)
apidog.com
. Em CI, você pode marcar falhas ao primeiro erro e, ao final, gerar relatórios de cobertura.
Ambiente de Staging: Para testes mais realistas, tenha um ambiente de staging (pré-produção) deployado. Executar testes de smoke e integrações contínuas no staging (por ex., via Cypress/Playwright) antes da release aumenta a confiabilidade.
### 8. Ferramentas e Recursos Adicionais
Validação e Emulação Firebase: Como estamos na suíte Firebase Studio, lembre-se dos Emuladores Firebase (Autenticação, Firestore, etc.) incorporados no Firebase CLI. Você pode executar testes unitários ou integração que precisam desses serviços emulados.
Documentação Oficial: Consulte sempre a documentação oficial do Firebase Studio e do Nix dev.nix
firebase.google.com
 para detalhes sobre ambiente. O blog do Firebase (como o artigo “Simplify development with public ports in Firebase Studio”
firebase.blog
firebase.blog
) traz dicas atualizadas sobre funcionalidade de preview e portas públicas.
Resumo: O objetivo é garantir cobertura completa das funcionalidades de leilão em todas as camadas de teste. Use testes unitários para lógica pura, integração para fluxo servidor/BD e E2E para fluxos críticos. Mantenha schemas Prisma/MySQL e Zod sincronizados via migrations e geradores automáticos
github.com
. Adote boas ferramentas (Vitest/Jest, Supertest, Playwright, zod-fixture) e uma infraestrutura de teste sólida (banco isolado, CI, staging). Assim, o desenvolvedor terá orientações claras e exemplos concretos para implementar imediatamente a estratégia de testes.

## 4. Princípio da Não-Regressão e Autorização Humana

**Regra:** Qualquer exclusão de funcionalidade, componente ou alteração significativa no projeto **deve ser explicitamente autorizada por um usuário humano**. Para evitar a remoção acidental de funcionalidades que estão operando corretamente ao implementar correções ou melhorias, a IA deve:

1.  Declarar claramente a intenção de excluir ou refatorar um componente/arquivo/funcionalidade.
2.  Fornecer uma breve justificativa sobre por que a mudança é necessária.
3.  Solicitar confirmação explícita do usuário antes de gerar as alterações.

**Justificativa:** Este princípio garante que o processo de desenvolvimento esteja sempre avançando e evita regressões. Ele mantém uma salvaguarda onde o desenvolvedor humano tem a palavra final sobre quaisquer alterações destrutivas ou em larga escala, preservando a estabilidade e a integridade do projeto.

## 5. Gerenciamento de Dependências

**Regra:** Para manter o projeto otimizado e evitar o crescimento excessivo do diretório `node_modules` e dos pacotes de produção, siga estas diretrizes:
-   **Dependências de Desenvolvimento:** Pacotes usados exclusivamente para desenvolvimento, teste ou processos de build (e.g., `@playwright/test`, `puppeteer` para geração de PDF no servidor) **devem** ser instalados como `devDependencies`. Isso impede que eles sejam incluídos no build de produção.
-   **Análise de Pacotes Pesados:** Antes de adicionar uma nova dependência, especialmente para funcionalidades não essenciais, avalie seu tamanho e impacto.
-   **Revisão Periódica:** Revise periodicamente o `package.json` para remover dependências não utilizadas.

**Justificativa:** Um `node_modules` grande e pacotes de produção inchados podem levar a tempos de instalação mais longos, builds mais lentos e custos de hospedagem mais altos. Manter as dependências limpas e otimizadas é crucial para a saúde do projeto.

## 6. Integridade de Links (Next.js)

**Regra:** Nunca permita que a propriedade `href` de um componente `<Link>` do Next.js seja `undefined`.

-   **Validação Obrigatória:** Se o `href` for dinâmico (vindo de uma API, props, ou estado), sempre valide se o valor existe antes de renderizar o `<Link>`.
-   **Estratégias de Fallback:**
    -   Use um link padrão (e.g., `href={item.url || '#'}`).
    -   Renderize o link condicionalmente (e.g., `{item.url && <Link.../>}`).
    -   Renderize um elemento alternativo (e.g., `<span>`) se o link não estiver disponível.

**Justificativa:** Um `href` indefinido causa um erro fatal de renderização no Next.js (`Error: Failed prop type`). Garantir a validade do `href` previne crashes e melhora a robustez da aplicação.

## 7. Estratégia de Testes para Aplicação de Leilões Full-Stack
### 1. Camadas e Tipos de Teste
Testes Unitários: Validam pequenas unidades de código isoladamente (funções, métodos, validações). São rápidos e não dependem de banco de dados ou rede, focando apenas na lógica interna. Por exemplo, testar uma função que calcula o próximo lance válido ou valida se um campo obrigatório está presente. Esse tipo de teste “isola a lógica garantindo que cada unidade funcione como esperado”
mendoncadev.com.br
.
Testes de Integração: Verificam a interação entre componentes ou módulos, incluindo acesso a banco de dados ou APIs externas. Por exemplo, testar um endpoint REST de cadastro de usuário usando um servidor Express e um banco MySQL real via Docker. Isso garante que controladores, serviços e camada de dados estão integrados corretamente. Os testes de integração “garantem que módulos e componentes do sistema funcionem corretamente juntos”
mendoncadev.com.br
.
Testes End-to-End (E2E): Simulam fluxos completos do usuário final, exercitando toda a pilha (front-end, back-end, banco de dados, etc.). Por exemplo, um teste E2E pode abrir a interface web do leilão, registrar um usuário, habilitá-lo, efetuar lances válidos/inválidos e gerar relatórios, tudo via UI ou API. Os testes E2E “verificam a funcionalidade completa do aplicativo do início ao fim, simulando cenários reais de usuários”
apidog.com
. Eles são mais lentos e devem focar em jornadas críticas (p. ex. finalização de leilão), deixando os detalhes menores para testes unitários.
### 2. Consistência de Schemas
Para evitar divergências entre o banco de dados, o schema do Prisma e os esquemas Zod:
Migrations e Versionamento: Sempre use Prisma Migrate para controlar alterações do schema MySQL. Toda modificação no model do Prisma deve ser migrada ao banco (via prisma migrate), garantindo que o BD real reflita o schema Prisma.
Geradores Automáticos: Utilize geradores que sincronizam Zod e Prisma. Por exemplo, o zod-prisma cria automaticamente esquemas Zod baseados no modelo Prisma, evitando ter que manter manualmente cada mudança de schema
github.com
. Bibliotecas NPM como prisma-zod-generator ou zod-prisma geram código Zod a partir do modelo, mantendo-os 1:1.
Validações Automatizadas: Além do tsc (TypeScript) que já aponta inconsistências de tipo, considere testes que carreguem os esquemas Zod gerados e comparem contra a saída do banco. Ferramentas como zod-fixture geram fixtures de teste a partir de esquemas Zod
github.com
, ajudando a validar entradas/saídas. Outra prática é escrever testes que tentem gravar entradas inválidas (segundo o Zod) no BD, confirmando que o middleware de validação bloqueia o acesso indevido. Dessa forma, o schema Zod (API) e o schema Prisma (BD) permanecem alinhados.
### 3. Cobertura de Funcionalidades do Leilão
Teste todos os fluxos principais da aplicação de leilões:
Cadastro e Habilitação: Teste unitário para validar regras de formato de dados de cadastro. Testes de integração via API para verificar que /api/usuarios cria o usuário no banco e que háflows como envio de e-mail ou notificações. Por exemplo, com Supertest pode-se validar que POST /api/usuarios retorna 201 e corpo JSON contendo o ID gerado.
Lances Válidos/Inválidos: Em lógica de negócios, escreva testes unitários para regras de lance (p. ex. “um lance deve ser maior que o último lance válido ou seguir incremento mínimo”). Em testes de integração, faça chamadas ao endpoint de lances (ex.: POST /api/lances) inserindo dados válidos e inválidos, verificando códigos de resposta e mensagens de erro. Por exemplo:
import request from 'supertest';
import { app } from '../src/app';

describe('POST /api/lances', () => {
  it('deve rejeitar lance abaixo do mínimo', async () => {
    const res = await request(app)
      .post('/api/lances')
      .send({ valor: 0.50, loteId: 'abc123', usuarioId: 1 });
    expect(res.status).toBe(400);
    expect(res.body).toHaveProperty('erro');
  });
});
Encerramento de Leilão: Teste a rotina que encerra o leilão (cron job ou função manual). Por exemplo, ao simular o fim do prazo, verificar que o status do leilão passa para “encerrado” e um vencedor é definido. Escreva testes de integração para endpoints de finalização ou simulação de tempo, garantindo atualização correta do BD.
Geração de Relatórios: Se a aplicação gera relatórios (por exemplo, somatório de lances ou visitas por leilão), crie testes que insiram dados no BD e consultem a API de relatório, verificando consistência dos valores agregados. Teste queries complexas no banco usando fixtures de dados.
Consultas com Joins Complexos: Para funcionalidades que exibem dados combinados (p. ex. cards de visitação que mostram Leilão + Lote + Comitente + Lances + Visitas), escreva testes de integração/prisma que gerem registros de cada entidade e consultem via Prisma com include ou join. Por exemplo:
const visita = await prisma.visita.findFirst({
  include: { leilao: true, lote: true, comitente: true, lances: true }
});
expect(visita).toMatchObject({
  leilao: { /* dados do leilão esperado */ },
  lote: { /* dados do lote */ },
  comitente: { /* dados do comitente */ },
  lances: expect.any(Array)
});
Isso garante que a consulta traga todas as relações corretas. Em testes E2E, valide também a interface (front-end) exibindo corretamente esses dados complexos.
### 4. Estratégia de Banco de Testes
Banco Real Isolado: Use uma instância MySQL separada (via Docker) para os testes. Um container mysql:8 isolado evita interferir nos dados de desenvolvimento. Configure o .env.test ou variável DATABASE_URL apontando para esse DB de teste. Em CI, você pode usar serviços do GitHub Actions ou Docker Compose para provisionar o MySQL antes dos testes.
Setup/Reset: Antes da suíte de testes, aplique as migrações: por exemplo, npx prisma migrate deploy ou prisma migrate reset --force. Entre cada teste (ou suíte), limpe o estado do banco – isso pode ser feito via transações que são revertidas (jdbc), truncando tabelas ou recriando o banco entre suites. Em frameworks como Jest/Vitest, use hooks beforeAll e afterAll para inicializar e limpar. Garantir que cada teste comece de um estado conhecido elimina efeitos colaterais.
Ambiente de Teste Separado: Utilize variáveis de ambiente para diferenciar ambiente de teste. Por exemplo, NODE_ENV=test ou DATABASE_URL distinta. Isso evita rodar testes em bases de dados de produção ou desenvolvimento. No código de inicialização do app, carregue o .env.test quando apropriado. Além disso, prefira configurações específicas de teste (sem portas em uso, logs reduzidos) para manter a performance do pipeline.
### 5. Ferramentas Recomendadas
Test Runner (Unit/Integração): Vitest e Jest são os mais usados. O Vitest é um runner moderno que funciona muito bem com projetos Vite/Next.js e TypeScript. Ele oferece API compatível com Jest e destacável foco em velocidade (“Vite significa rápido” – muitas vezes executa testes diversas vezes mais rápido que Jest)
saucelabs.com
. Jest é maduro, amplamente suportado e não exige configuração extra para projetos comuns. Em geral, Vitest tende a ser recomendado para projetos com Vite ou Next.js modernos devido à performance, enquanto Jest é sólido se você já o conhece ou precisa de recursos avançados como snapshot testing.
Simulação de APIs (Integração): Supertest é excelente para testar endpoints HTTP em aplicações Express/Koa/etc
mendoncadev.com.br
. Ele permite emitir requisições (GET, POST, etc.) diretamente contra o servidor em memória. Use-o para testes de integração REST. Outra opção é Axios combinado com um servidor local ou nock para simular respostas de serviços externos.
Validação de Dados: Para criar dados de teste consistentes a partir de esquemas, use zod-fixture, que “cria fixtures de teste baseados em um schema Zod”
github.com
. Com ele você evita criar manualmente objetos de teste. Também considere bibliotecas como faker.js para dados randômicos e Prisma Factory (npm) para construir entidades completas.
Testes End-to-End: Playwright (Microsoft) é uma ferramenta robusta de E2E que suporta múltiplos navegadores e linguagens. Ao contrário do Cypress (que roda dentro do navegador e é limitado a JS/TS), o Playwright roda fora e oferece suporte a diversos navegadores e paralelismo embutido
checklyhq.com
. O Cypress tem ótima experiência de uso e depuração integrada, mas não suporta Safari nem múltiplas abas, e o paralelismo requer serviço pago. Recomenda-se Playwright para testes E2E amplos (ex.: fluxos completos de usuário) e Cypress se focar em testes front-end JS/TS com feedback interativo.
Outras Ferramentas: Para teste de front-end React, use Testing Library (React Testing Library) ou Vitest com JSDOM para componentes UI isolados. Para bancos em memória, considere SQLite in-memory ou Prisma DSN especial. Ferramentas de CI de testes (como Coveralls) podem ser integradas posteriormente, mas foque primeiro na cobertura de funcionalidades.
### 6. Integração com Firebase Studio
Prototyper de IA (App Prototyping Agent): O Firebase Studio inclui um agente de prototipagem por IA (chamado Prototyper ou App Prototyping agent) que gera automaticamente código de aplicação full-stack a partir de prompts multimodais
firebase.google.com
. Ao descrever a ideia da app em linguagem natural, o agente cria um “blueprint”, o código-fonte correspondente e um preview da aplicação. Esse código gerado é injetado diretamente no workspace (IDE VSCode) do Firebase Studio, permitindo que o desenvolvedor revise ou modifique imediatamente no ambiente de código. Em outras palavras, o desenvolvedor trabalha no VSCode web do Firebase Studio e o Prototyper populos generationa arquivos editáveis nesse mesmo editor
firebase.google.com
.
Testando o Preview (VM Fechada): O preview da aplicação no Firebase Studio roda numa VM isolada. Para testar via scripts externos (Playwright, etc.), use a funcionalidade “Make Preview Public”. No próprio Firebase Studio, abra o preview web e clique em “Make Preview Public” na toolbar
firebase.blog
. Isso libera um URL externo (indicado por um ícone de globo amarelo) que qualquer máquina pode acessar temporariamente. A figura abaixo mostra como fica o painel de portas e o botão de pré-visualização pública: Figura: No Firebase Studio, abra o painel “Backend Ports” (Ctrl+',' → “Backend Ports”) e clique no cadeado para liberar a porta do backend publicamente
firebase.blog
. Uma vez liberada, aparece o ícone de globo que indica URL público. Figura: Na aba de preview web do Firebase Studio, clique em “Make Preview Public” (ícone de cadeado) para obter um link público da aplicação
firebase.blog
. O ícone muda para globo amarelo, sinalizando acesso externo. Após tornar o preview público, scripts de teste (por exemplo, Playwright rodando localmente) podem navegar até esse URL e interagir com a aplicação completa. Lembre que essa URL é temporária (ativas apenas enquanto a workspace está ativa)
firebase.blog
.
Configuração do .idx/dev.nix: Se você for rodar testes E2E (Playwright) no ambiente Nix do Firebase Studio, adicione o Chromium no seu .idx/dev.nix. Exemplo de configuração:
{pkgs, ...}: {
  channel = "stable-24.05";
  packages = [
    pkgs.chromium
    # ... outros pacotes necessários (nodejs, python, etc.) ...
  ];
  env = {
    CHROME_BIN = "/usr/bin/chromium";
    # PATH é gerenciado automaticamente, mas outros vars podem ser definidos aqui
  };
}
Isso garante que o Chromium esteja instalado na VM e que a variável CHROME_BIN aponte para o binário, permitindo que o Playwright o utilize
firebase.google.com
firebase.google.com
. Sem essa configuração, o Playwright pode não encontrar um navegador.
Make Preview Public e Portas Públicas: Além do front-end, o Firebase Studio permite liberar portas de backend (por exemplo, porta 3000 do Node) para acesso público
firebase.blog
. Isso é útil para integrar frontend e backend sem alterar o código (basta apontar o front-end para a URL pública do backend). O botão de cadeado no painel de “Backend Ports” abre a porta, e o front-end pode consumi-la pela URL fornecida
firebase.blog
. Contudo, lembre-se que essas portas públicas são temporárias e apenas para desenvolvimento/teste, não substituem uma deployment de produção.
### 7. Organização da Suíte de Testes
Estrutura de Pastas: Separe os testes por tipo. Por exemplo:
/tests
  /unit         # testes unitários
  /integration  # testes de API/integração
  /e2e          # testes end-to-end
Ou coloque tests ao lado dos arquivos de código. Mantenha fixtures em pastas dedicadas (/tests/fixtures) e evite duplicação de dados.
Nomenclatura e Configurações: Use convenções como *.test.ts ou *.spec.ts. Caso use Jest/Vitest, crie arquivos de configuração separados (por exemplo, jest.unit.config.js, jest.integration.config.js ou equivalentes para Vitest) para cada contexto. Isso permite, por exemplo, desabilitar a emulação de rede nos unitários e habilitá-la nos integrações.
Scripts de Execução: No package.json, defina scripts para cada categoria:
{
  "scripts": {
    "test:unit": "vitest run --config vitest.unit.config.ts",
    "test:integration": "vitest run --config vitest.integration.config.ts",
    "test:e2e": "playwright test",
    "test": "npm-run-all test:unit test:integration test:e2e"
  }
}
Com esses scripts, o desenvolvedor pode executar apenas um tipo de teste (ex.: npm run test:unit) ou todos em sequência (npm test). Ajuste conforme seu runner: para Jest, por exemplo, use flags em cada config específica.
Integração Contínua (CI): Configure seu pipeline (ex.: GitHub Actions) para instalar dependências, iniciar o banco de testes e rodar todas as suites. Exemplo de trecho de workflow YAML com MySQL:
jobs:
  tests:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: root
        ports:
          - 3306:3306
    env:
      NODE_ENV: test
      DATABASE_URL: mysql://root:root@localhost:3306/leiloes_test
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npx prisma migrate deploy
      - run: npm test
Isso executa todas as etapas de teste em um ambiente isolado. A pirâmide de testes orienta a ter muitos testes unitários (base) e poucos E2E (topo)
apidog.com
. Em CI, você pode marcar falhas ao primeiro erro e, ao final, gerar relatórios de cobertura.
Ambiente de Staging: Para testes mais realistas, tenha um ambiente de staging (pré-produção) deployado. Executar testes de smoke e integrações contínuas no staging (por ex., via Cypress/Playwright) antes da release aumenta a confiabilidade.
### 8. Ferramentas e Recursos Adicionais
Validação e Emulação Firebase: Como estamos na suíte Firebase Studio, lembre-se dos Emuladores Firebase (Autenticação, Firestore, etc.) incorporados no Firebase CLI. Você pode executar testes unitários ou integração que precisam desses serviços emulados.
Documentação Oficial: Consulte sempre a documentação oficial do Firebase Studio e do Nix dev.nix
firebase.google.com
 para detalhes sobre ambiente. O blog do Firebase (como o artigo “Simplify development with public ports in Firebase Studio”
firebase.blog
firebase.blog
) traz dicas atualizadas sobre funcionalidade de preview e portas públicas.
Resumo: O objetivo é garantir cobertura completa das funcionalidades de leilão em todas as camadas de teste. Use testes unitários para lógica pura, integração para fluxo servidor/BD e E2E para fluxos críticos. Mantenha schemas Prisma/MySQL e Zod sincronizados via migrations e geradores automáticos
github.com
. Adote boas ferramentas (Vitest/Jest, Supertest, Playwright, zod-fixture) e uma infraestrutura de teste sólida (banco isolado, CI, staging). Assim, o desenvolvedor terá orientações claras e exemplos concretos para implementar imediatamente a estratégia de testes.
```
- apphosting.yaml:
```yaml
# Settings to manage and configure a Firebase App Hosting backend.
# https://firebase.google.com/docs/app-hosting/configure

runConfig:
  # Increase this value if you'd like to automatically spin up
  # more instances in response to increased traffic.
  maxInstances: 1

```
- bidexpert-630df-firebase-adminsdk-fbsvc-4c89838d15.json:
```json
{
  "type": "service_account",
  "project_id": "bidexpert-630df",
  "private_key_id": "4c89838d15a6bb707f2ccb919bb61af31296ee28",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCwo+FwY4fwfJpm\nw+B//Z/dHQd0wdfpuIix+uXlPO1W85rdX9UNDeVdB8eZvEIEIGoRpKUtE4QvF6Ec\npdeAwYKGgEufWI5S9Yl8zsMEGP/ZvYrsWfuWUxCZahs4ExmJfyyiPAuMIXaNH1UD\nTr7Sv4QjaSpLeXBXkehECpsdtDm/AdtjNyK8amiMvfSJRuygjHV/vWS/eI/hkeLu\ntjp5awoouKkT7P/DZTf0EpYD1IjYiXB4EAubP7c+H0i8WYNDVV0tKPjosez4QNDx\nIKvTAEBSPbpMIzUjYSIZaeGYcPsweZG6q0smOrAEX4xK5cftsDdTbhz2NNodqlTI\nTZMned0hAgMBAAECggEAB8gAW1oXF/H1P0ersRe0HiJ0PKF5aHNXmjeKPxHzBpyO\nmufo071j+Dgqg8w2QEZJReOx3w14CjcJQuDPYH2lyVUHf8p/4omsd9IH5ztOsgHW\nh9ji61lXZtq0vkChJFx00+S/QXoL5eWWciHa6B/Fq2Wrlk2QNFtaFv08ng9dZ9uT\nU6FHBHQL4FRP1IJjmCpruLndUzz6YioZVVZXaxOhIaZ65mc1DQRqOuCFn5ah0yEz\noOQ6x3GFIyr/uk47yERYNiFf4/OVR5NTYPO2dtDuLcn3kjvPIHie1pnvXEsu9FfC\n6E8YfSK5Qku6aUGMfYq8RjqiWXKtxM/oEeJHmvApDQKBgQDfOzmX4b13jqxm6T1B\nWaz4zVzSAJNFlM2F7X447PHsUclLh2E/wm/nV4LOByGMD5SMu1kZeQqQHKEO2sJv\nXd+HzVciFdXjSN9BZJ9iLhNJAGtVPDaB9UOKb+5PoAtc/YJHsE8kZioGke+8Ixky\n9yeex14eaA14ci3trNI6o9YgkwKBgQDKkdAVkC8sXstmAQbpNdirU3HcKHqPoTrg\nHS4B9HuUucvCNCEJI61KSjTCCUSkIft5Dgpqq3KNT2nt3HNVpcgUd7WjoVZ5qlyZ\nXfGC4V2rnhFo23wkNr1EBf02yzbGw8t2XvQ+foRByT/HM2s9s0yUj1n8PhRMKtmF\nL6sY6oV/+wKBgHy1FWOoFLSp295SBopvkpYcA/K9p4iDrJ1ZI96hYDVpK08qfkWk\nVeejl8uJaFBak95a+1ejqyb/F2q5A0473xh6umasVCT5HN/nWrL6koOB3HRtgvXv\nEqBQD44kFrUIWrO55zyqZmftN0SfRwCV2mh1cDsEXiIfh1Dz7y4bQRBJAoGAA9hY\nttAR1SnHepwyYWLgRgBDfQZXrTpGP9LN+MOHRP9x2rHanq3KsEpQTg6W+vaaK2YU\n1ImElyIWxKkWl12aOqk7DWwWlCCjuVWLLAzTFlrdwbvI03cmiJAEinG5DHTS++A5\niqYkJIuJZmKXeohYv8ko0BztjbSShHCvMr3g4tkCgYEAjKGnXeu3u/bv+1r9xvTR\nQUookeFXAW0DsVYk2EsuxMDTNBXMYAY83tQl72y2lU3kPTVklsfOYkYMia6X9rwR\njEwsirhlzZjZzoyxY1nO1z12AKCafNY84KzrLBu7Pmiazvm3jGcuzAGo+xwE4UKP\nKoEH2iDgxogR/TTy6u4oOcw=\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@bidexpert-630df.iam.gserviceaccount.com",
  "client_id": "109586758228480352128",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40bidexpert-630df.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}

```
- components/BidReportBuilder/README.md:
```md

```
- components/BidReportBuilder/__tests__/BidReportBuilder.test.js:
```js

```
- components/BidReportBuilder/api/reports.js:
```js

```
- components/BidReportBuilder/components/AIPanel.js:
```js

```
- components/BidReportBuilder/components/DataSourceManager.js:
```js

```
- components/BidReportBuilder/components/MediaLibrary.js:
```js

```
- components/BidReportBuilder/components/PreviewPanel.js:
```js

```
- components/BidReportBuilder/components/PropertiesPanel.js:
```js

```
- components/BidReportBuilder/components/ReportDesigner.js:
```js

```
- components/BidReportBuilder/components/Toolbar.js:
```js

```
- components/BidReportBuilder/components/VariablePanel.js:
```js

```
- components/BidReportBuilder/index.js:
```js

```
- components/BidReportBuilder/styles/ReportBuilder.css:
```css

```
- components/BidReportBuilder/tour.js:
```js

```
- components/ReportDesigner/components/DesignSurface.js:
```js

```
- components/ReportDesigner/components/PropertiesPanel.js:
```js

```
- components/ReportDesigner/components/Toolbar.js:
```js

```
- components/ReportDesigner/index.js:
```js

```
- components/admin/wizard/FlowStepNode.tsx:
```tsx
// src/components/admin/wizard/FlowStepNode.tsx
import { cn } from '@/lib/utils';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Check, CircleDot, Circle, Plus, type LucideIcon, Pencil } from 'lucide-react';
import React, { memo, useState } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { useWizard } from './wizard-context'; // Import useWizard hook

export interface FlowNodeData {
  label?: string;
  title: string;
  status: 'todo' | 'in_progress' | 'done';
  icon?: LucideIcon;
  pathType: 'JUDICIAL' | 'EXTRAJUDICIAL' | 'PARTICULAR' | 'TOMADA_DE_PRECOS' | 'COMMON';
  isActivePath: boolean;
  isEntity?: boolean; // Flag to indicate if this node represents a created entity
  entityId?: string | number; // ID of the entity to link to
  entityType?: 'process' | 'auctioneer' | 'seller'; // Type of entity
}

const pathStyles: Record<string, { node: string, label: string }> = {
    JUDICIAL: { node: "border-blue-500/80", label: "bg-blue-500/80 text-white" },
    EXTRAJUDICIAL: { node: "border-emerald-500/80", label: "bg-emerald-500/80 text-white" },
    PARTICULAR: { node: "border-orange-500/80", label: "bg-orange-500/80 text-white" },
    TOMADA_DE_PRECOS: { node: "border-violet-500/80", label: "bg-violet-500/80 text-white" },
    COMMON: { node: "border-slate-400/80", label: "bg-slate-400/80 text-white" }
};

const statusIcons = {
  done: <Check className="h-4 w-4" />,
  in_progress: <CircleDot className="h-4 w-4 animate-pulse" />,
  todo: <Circle className="h-4 w-4" />,
};

const entityLinks: Record<string, string> = {
  process: '/admin/judicial-processes',
  auctioneer: '/admin/auctioneers',
  seller: '/admin/sellers',
};

const FlowStepNode = ({ data }: NodeProps<FlowNodeData>) => {
  const { label, title, status, icon: Icon, pathType, isActivePath, isEntity, entityId, entityType } = data;
  const { wizardData } = useWizard(); // Access wizardData
  
  const styles = pathStyles[pathType] || pathStyles.COMMON;
  const statusIcon = statusIcons[status];
  const highlightClass = isActivePath ? 'opacity-100' : 'opacity-40 hover:opacity-100';
  const [isHovered, setIsHovered] = useState(false);
  
  let finalTitle = title;
  
  if (entityType === 'process' && wizardData.judicialProcess) {
    finalTitle = `Proc: ${wizardData.judicialProcess.processNumber}`;
  } else if (entityType === 'auctioneer' && wizardData.auctionDetails?.auctioneer) {
    finalTitle = wizardData.auctionDetails.auctioneer;
  } else if (entityType === 'seller' && wizardData.auctionDetails?.seller) {
    finalTitle = wizardData.auctionDetails.seller;
  }

  const editLink = (isEntity && entityType && entityId) ? `${entityLinks[entityType]}/${entityId}/edit` : null;

  return (
    <>
      <Handle type="target" position={Position.Left} className="!bg-primary" />
      <div 
        className={cn("w-56 rounded-md bg-card border-2 shadow-sm p-0.5 transition-opacity relative", styles.node, highlightClass)}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
      >
        {isHovered && editLink && (
            <Button asChild size="icon" variant="outline" className="absolute -top-3 -right-3 h-7 w-7 bg-background z-10">
                <Link href={editLink} target="_blank" title="Editar entidade">
                    <Pencil className="h-4 w-4 text-primary" />
                </Link>
            </Button>
        )}
        {label && (
          <div className={cn("px-2 py-0.5 text-xs font-semibold rounded-t-sm", styles.label)}>
            {label}
          </div>
        )}
        <div className="p-3 bg-card rounded-b-sm">
          <div className="flex items-center justify-between">
            <div className="flex items-start gap-2 min-w-0">
              {Icon && <Icon className="h-5 w-5 text-muted-foreground mt-0.5 flex-shrink-0" />}
              <p className="font-semibold text-sm whitespace-normal break-words" title={finalTitle}>
                {finalTitle}
              </p>
            </div>
            <div className="text-muted-foreground ml-2 flex-shrink-0">{statusIcon}</div>
          </div>
        </div>
      </div>
      <Handle type="source" position={Position.Right} className="!bg-primary" />
    </>
  );
};

export default memo(FlowStepNode);

```
- components/admin/wizard/WizardFlow.tsx:
```tsx
// src/components/admin/wizard/WizardFlow.tsx
'use client';

import React, { useMemo } from 'react';
import ReactFlow, { Background, Controls, Edge, Node } from 'reactflow';
import 'reactflow/dist/style.css';
import { useWizard } from './wizard-context';
import FlowStepNode, { type FlowNodeData } from './FlowStepNode';
import { Gavel, Users, Building, FileText, Scale, Package, Boxes, ListChecks, Rocket, DollarSign, Tv, CalendarX } from 'lucide-react';

const nodeTypes = {
  customStep: FlowStepNode,
};

const pathColors: Record<string, string> = {
  JUDICIAL: '#3b82f6', // blue-500
  EXTRAJUDICIAL: '#22c55e', // green-500
  PARTICULAR: '#f97316', // orange-600
  TOMADA_DE_PRECOS: '#8b5cf6', // violet-500
  COMMON: '#64748b', // slate-500
};

export default function WizardFlow() {
  const { wizardData, currentStep } = useWizard();
  
  const { nodes, edges } = useMemo(() => {
    // We only need these specific values, not the whole wizardData object,
    // to avoid re-rendering on every keystroke in the form.
    const { 
        auctionType: selectedType, 
        judicialProcess, 
        auctionDetails, 
        createdLots 
    } = wizardData;

    let nodeIdCounter = 1;
    const allNodes: Node<FlowNodeData>[] = [];
    const allEdges: Edge[] = [];
    const xGap = 280;
    const yGap = 120;
    
    const commonIsActive = !!selectedType;
    const commonEdgeStyle = { stroke: pathColors.COMMON };
    const judicialPathIsActive = !selectedType || selectedType === 'JUDICIAL';
    const judicialEdgeStyle = { stroke: pathColors.JUDICIAL, strokeWidth: judicialPathIsActive ? 2.5 : 1.5 };
    
    const judicialYPos = 1.5 * yGap;
    const otherPathsYBase = 4.5 * yGap;
    const convergenceY = (judicialYPos + otherPathsYBase) / 2;
    
    allNodes.push({
      id: 'start', type: 'customStep', position: { x: 0, y: convergenceY },
      data: { title: 'Início do Cadastro', status: 'done', icon: Rocket, pathType: 'COMMON', isActivePath: true, label: `#${nodeIdCounter++} - Ponto de Partida` },
    });

    const auctionTypes = ['JUDICIAL', 'EXTRAJUDICIAL', 'PARTICULAR', 'TOMADA_DE_PRECOS'] as const;
    auctionTypes.forEach((type, index) => {
      const yPos = (type === 'JUDICIAL') ? judicialYPos : otherPathsYBase + (index - 1) * 1.5 * yGap;
      const isActivePath = !selectedType || selectedType === type;
      allNodes.push({
        id: `type-${type}`, type: 'customStep', position: { x: xGap, y: yPos },
        data: { label: `#${nodeIdCounter++} - Modalidade`, title: type.replace(/_/g, ' '), status: selectedType ? 'done' : 'in_progress', pathType: type, isActivePath }
      });
      allEdges.push({ id: `e-start-${type}`, source: 'start', target: `type-${type}`, type: 'smoothstep', style: { stroke: pathColors[type], strokeWidth: isActivePath ? 2.5 : 1.5 }, animated: isActivePath && currentStep >= 0 });
    });

    const judicialInputs = [
        { id: 'tribunal', title: 'Tribunal', icon: Scale, position: { x: xGap * 2.5, y: judicialYPos - yGap * 1.2 } },
        { id: 'comarca', title: 'Comarca', icon: Building, position: { x: xGap * 2.5, y: judicialYPos - yGap * 0.4 } },
        { id: 'vara', title: 'Vara', icon: Gavel, position: { x: xGap * 2.5, y: judicialYPos + yGap * 0.4 } },
        { id: 'partes', title: 'Partes Envolvidas', icon: Users, position: { x: xGap * 2.5, y: judicialYPos + yGap * 1.2 } }
    ];
    judicialInputs.forEach(node => {
        allNodes.push({ id: `judicial-input-${node.id}`, type: 'customStep', position: node.position, data: { label: `Input Judicial`, title: node.title, status: judicialProcess ? 'done' : 'todo', icon: node.icon, pathType: 'JUDICIAL', isActivePath: judicialPathIsActive } });
    });
    
    const judicialProcessNodeId = 'judicial-processo';
    allNodes.push({
        id: judicialProcessNodeId, type: 'customStep', position: { x: xGap * 4, y: judicialYPos },
        data: { label: '#9 - Passo 1 (Judicial)', title: 'Processo Judicial', icon: FileText, status: judicialProcess ? 'done' : (currentStep === 1 && selectedType === 'JUDICIAL' ? 'in_progress' : 'todo'), pathType: 'JUDICIAL', isActivePath: judicialPathIsActive, isEntity: true, entityType: 'process', entityId: judicialProcess?.id }
    });
    allEdges.push({ id: `e-type-JUDICIAL-processo`, source: 'type-JUDICIAL', target: judicialProcessNodeId, type: 'smoothstep', style: judicialEdgeStyle, animated: judicialPathIsActive && currentStep >= 1 });
    judicialInputs.forEach(node => {
        allEdges.push({ id: `e-input-${node.id}-processo`, source: `judicial-input-${node.id}`, target: judicialProcessNodeId, type: 'smoothstep', style: judicialEdgeStyle });
    });

    // --- AUCTION ENTITY PRE-REQUISITES (for all paths) ---
    const sellerId = auctionDetails?.sellerId;
    const auctioneerId = auctionDetails?.auctioneerId;
    allNodes.push({ id: 'entity-comitente', type: 'customStep', position: { x: xGap * 4, y: otherPathsYBase + yGap * 0.8 }, data: { label: '#10 - Entidade', title: 'Comitente', icon: Users, status: sellerId ? 'done' : 'todo', pathType: 'COMMON', isActivePath: commonIsActive, isEntity: true, entityId: sellerId, entityType: 'seller'} });
    allNodes.push({ id: 'entity-leiloeiro', type: 'customStep', position: { x: xGap * 4, y: otherPathsYBase + yGap * 1.8 }, data: { label: '#11 - Entidade', title: 'Leiloeiro', icon: Gavel, status: auctioneerId ? 'done' : 'todo', pathType: 'COMMON', isActivePath: commonIsActive, isEntity: true, entityId: auctioneerId, entityType: 'auctioneer' } });

    // --- AUCTION DETAILS NODE ---
    const auctionDetailsNodeId = 'auction-details';
    allNodes.push({
      id: auctionDetailsNodeId, type: 'customStep', position: { x: xGap * 5.5, y: otherPathsYBase },
      data: { label: `#12 - Passo 2`, title: 'Dados do Leilão', status: auctionDetails?.title ? 'done' : ((currentStep === 1 && selectedType !== 'JUDICIAL') || currentStep === 2 ? 'in_progress' : 'todo'), icon: Gavel, pathType: selectedType || 'COMMON', isActivePath: commonIsActive }
    });
    
    ['EXTRAJUDICIAL', 'PARTICULAR', 'TOMADA_DE_PRECOS'].forEach(type => {
        allEdges.push({ id: `e-type-${type}-auction`, source: `type-${type}`, target: auctionDetailsNodeId, type: 'smoothstep', style: { stroke: pathColors[type as keyof typeof pathColors], strokeWidth: selectedType === type ? 2.5 : 1.5 }, animated: selectedType === type });
    });
    allEdges.push({ id: `e-entity-comitente-auction`, source: 'entity-comitente', target: auctionDetailsNodeId, type: 'smoothstep', style: commonEdgeStyle });
    allEdges.push({ id: `e-entity-leiloeiro-auction`, source: 'entity-leiloeiro', target: auctionDetailsNodeId, type: 'smoothstep', style: commonEdgeStyle });

    // --- SOURCE OF ASSETS NODES ---
    const bensProcessoNodeId = 'bens-do-processo';
    const bensComitenteNodeId = 'bens-do-comitente';
    
    allNodes.push({
        id: bensProcessoNodeId, type: 'customStep', position: { x: xGap * 7, y: judicialYPos },
        data: { label: `Fonte de Itens`, title: 'Bens do Processo', icon: Package, status: judicialProcess ? 'done' : 'todo', pathType: 'JUDICIAL', isActivePath: judicialPathIsActive }
    });
    allEdges.push({ id: 'e-processo-bens', source: judicialProcessNodeId, target: bensProcessoNodeId, type: 'smoothstep', style: judicialEdgeStyle });
    
    allNodes.push({
      id: bensComitenteNodeId, type: 'customStep', position: { x: xGap * 5.5, y: otherPathsYBase + yGap * 1.3},
      data: { label: `Fonte de Itens`, title: 'Bens do Comitente', icon: Package, status: sellerId ? 'done' : 'todo', pathType: 'COMMON', isActivePath: commonIsActive && selectedType !== 'JUDICIAL' }
    });
    allEdges.push({ id: 'e-comitente-bens', source: 'entity-comitente', target: bensComitenteNodeId, type: 'smoothstep', style: commonEdgeStyle });


    // --- LOTTING NODE ---
    const lottingNodeId = 'lotting';
    allNodes.push({
      id: lottingNodeId, type: 'customStep', position: { x: xGap * 8.5, y: convergenceY },
      data: { label: '#14 - Passo 3', title: 'Criação de Lotes', status: createdLots && createdLots.length > 0 ? 'done' : currentStep === 3 ? 'in_progress' : 'todo', icon: Boxes, pathType: selectedType || 'COMMON', isActivePath: commonIsActive }
    });
    
    allEdges.push({ id: `e-bens-processo-lotting`, source: bensProcessoNodeId, target: lottingNodeId, type: 'smoothstep', style: judicialEdgeStyle, animated: judicialPathIsActive && currentStep >= 3 });
    allEdges.push({ id: `e-bens-comitente-lotting`, source: bensComitenteNodeId, target: lottingNodeId, type: 'smoothstep', style: commonEdgeStyle, animated: commonIsActive && selectedType !== 'JUDICIAL' && currentStep >= 3 });
    allEdges.push({ id: `e-auction-lotting`, source: auctionDetailsNodeId, target: lottingNodeId, type: 'smoothstep', style: commonEdgeStyle, animated: commonIsActive && currentStep >= 3 });

    // --- REVIEW NODE ---
    const reviewNodeId = 'review';
    allNodes.push({
      id: reviewNodeId, type: 'customStep', position: { x: xGap * 10, y: convergenceY },
      data: { label: '#15 - Passo Final', title: 'Revisão e Publicação', status: currentStep === 4 ? 'in_progress' : 'todo', icon: ListChecks, pathType: selectedType || 'COMMON', isActivePath: commonIsActive }
    });
    allEdges.push({ id: `e-lotting-review`, source: lottingNodeId, target: reviewNodeId, type: 'smoothstep', style: { stroke: selectedType ? pathColors[selectedType] : pathColors.COMMON }, animated: commonIsActive && currentStep >= 4 });

    // --- Post-Creation Lifecycle Nodes ---
    const postXBase = xGap * 11.5;
    const postYLine1 = convergenceY - yGap;
    const postYLine2 = convergenceY + yGap;
    
    allNodes.push({ id: 'leilao-ativo', type: 'customStep', position: {x: postXBase, y: postYLine1}, data: { label: '#16 - Pregão', title: 'Leilão Ativo (Lances)', status: 'todo', icon: Gavel, pathType: 'COMMON', isActivePath: commonIsActive }});
    allEdges.push({ id: 'e-review-ativo', source: reviewNodeId, target: 'leilao-ativo', type: 'smoothstep', style: commonEdgeStyle });
    
    allNodes.push({ id: 'pregao-auditorio', type: 'customStep', position: {x: postXBase + xGap, y: postYLine1}, data: { label: '#17 - Pregão', title: 'Pregão no Auditório', status: 'todo', icon: Tv, pathType: 'COMMON', isActivePath: commonIsActive }});
    allEdges.push({ id: 'e-ativo-pregao', source: 'leilao-ativo', target: 'pregao-auditorio', type: 'smoothstep', style: commonEdgeStyle });

    allNodes.push({ id: 'comunicacao-arrematante', type: 'customStep', position: { x: postXBase, y: postYLine2 }, data: { label: '#18 - Pós-Leilão', title: 'Comunicação c/ Arrematante', status: 'todo', icon: Users, pathType: 'COMMON', isActivePath: commonIsActive }});
    allEdges.push({ id: 'e-pregao-comunicacao', source: 'pregao-auditorio', target: 'comunicacao-arrematante', type: 'smoothstep', style: commonEdgeStyle });

    allNodes.push({ id: 'pagamento-docs', type: 'customStep', position: { x: postXBase + xGap, y: postYLine2 }, data: { label: '#19 - Pós-Leilão', title: 'Pagamento e Documentos', status: 'todo', icon: FileText, pathType: 'COMMON', isActivePath: commonIsActive }});
    allEdges.push({ id: 'e-comunicacao-pagamento', source: 'comunicacao-arrematante', target: 'pagamento-docs', type: 'smoothstep', style: commonEdgeStyle });
    
    allNodes.push({ id: 'encerramento', type: 'customStep', position: { x: postXBase + xGap * 2, y: postYLine2 }, data: { label: '#20 - Pós-Leilão', title: 'Encerramento', status: 'todo', icon: CalendarX, pathType: 'COMMON', isActivePath: commonIsActive }});
    allEdges.push({ id: 'e-pagamento-encerramento', source: 'pagamento-docs', target: 'encerramento', type: 'smoothstep', style: commonEdgeStyle });

    allNodes.push({ id: 'fluxo-financeiro', type: 'customStep', position: {x: postXBase + xGap * 3, y: postYLine2}, data: { label: '#21 - Financeiro', title: 'Fluxo Financeiro', status: 'todo', icon: DollarSign, pathType: 'COMMON', isActivePath: commonIsActive }});
    allEdges.push({ id: 'e-encerramento-financeiro', source: 'encerramento', target: 'fluxo-financeiro', type: 'smoothstep', style: commonEdgeStyle });

    return { nodes: allNodes, edges: allEdges };
  }, [wizardData.auctionType, wizardData.judicialProcess, wizardData.auctionDetails?.title, wizardData.auctionDetails?.sellerId, wizardData.auctionDetails?.auctioneerId, wizardData.createdLots?.length, currentStep]);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      nodeTypes={nodeTypes}
      fitView
      proOptions={{ hideAttribution: true }}
      className="bg-muted/30"
    >
      <Background />
      <Controls showInteractive={false} />
    </ReactFlow>
  );
}
```
- components/admin/wizard/page.tsx:
```tsx
// src/app/admin/wizard/page.tsx
'use client';

import { useEffect, useMemo, useState, useCallback } from 'react';
import { WizardProvider, useWizard } from '@/components/admin/wizard/wizard-context';
import WizardStepper from '@/components/admin/wizard/wizard-stepper';
import Step1TypeSelection from '@/components/admin/wizard/steps/step-1-type-selection';
import Step2JudicialSetup from '@/components/admin/wizard/steps/step-2-judicial-setup';
import Step3AuctionDetails from '@/components/admin/wizard/steps/step-3-auction-details';
import Step4Lotting from '@/components/admin/wizard/steps/step-4-lotting';
import Step5Review from '@/components/admin/wizard/steps/step-5-review';
import { getWizardInitialData } from './actions';
import type { JudicialProcess, LotCategory, AuctioneerProfileInfo, SellerProfileInfo, Bem, Auction, Court, JudicialDistrict, JudicialBranch, Lot } from '@/types';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { ChevronLeft, ChevronRight, Rocket, Loader2, Workflow, Eye, Search, Expand, PackagePlus } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { useRouter } from 'next/navigation';
import JudicialProcessForm from '@/app/admin/judicial-processes/judicial-process-form';
import { createJudicialProcessAction } from '@/app/admin/judicial-processes/actions';
import { createBem as createBemAction } from '@/app/admin/bens/actions';
import { Separator } from '@/components/ui/separator';
import WizardFlow from '@/components/admin/wizard/WizardFlow';
import WizardFlowModal from '@/components/admin/wizard/WizardFlowModal';
import BemForm from '@/app/admin/bens/bem-form';


const allSteps = [
  { id: 'type', title: 'Tipo de Leilão', description: 'Selecione a modalidade.' },
  { id: 'judicial', title: 'Dados Judiciais', description: 'Informações do processo.' },
  { id: 'auction', title: 'Dados do Leilão', description: 'Detalhes e datas.' },
  { id: 'lotting', title: 'Loteamento', description: 'Agrupe bens em lotes.' },
  { id: 'review', title: 'Revisão e Publicação', description: 'Revise e publique.' },
];

interface WizardDataForFetching {
    judicialProcesses: JudicialProcess[];
    categories: LotCategory[];
    auctioneers: AuctioneerProfileInfo[];
    sellers: SellerProfileInfo[];
    availableBens: Bem[];
    courts: Court[];
    districts: JudicialDistrict[];
    branches: JudicialBranch[];
}

function WizardContent({ 
    fetchedData, 
    isLoading, 
    refetchData, 
}: { 
    fetchedData: WizardDataForFetching | null;
    isLoading: boolean;
    refetchData: (newProcessIdToSelect?: string) => void;
}) {
  const { currentStep, wizardData, nextStep, prevStep, goToStep, setWizardData } = useWizard();
  const [wizardMode, setWizardMode] = useState<'main' | 'judicial_process' | 'bem'>('main');
  const [isDataRefetching, setIsDataRefetching] = useState(false);
  const router = useRouter();
  const { toast } = useToast();
  const [isFlowModalOpen, setIsFlowModalOpen] = useState(false);


  const stepsToUse = useMemo(() => {
    if (wizardData.auctionType === 'JUDICIAL') {
      return allSteps;
    }
    return allSteps.filter(step => step.id !== 'judicial');
  }, [wizardData.auctionType]);

  const currentStepId = stepsToUse[currentStep]?.id;
  
  const bensForLotting = useMemo(() => {
    if (!fetchedData?.availableBens) return [];

    if (wizardData.auctionType === 'JUDICIAL') {
      return wizardData.judicialProcess
        ? fetchedData.availableBens.filter(bem => bem.judicialProcessId === wizardData.judicialProcess!.id)
        : [];
    } else {
      return wizardData.auctionDetails?.sellerId
        ? fetchedData.availableBens.filter(bem => bem.sellerId === wizardData.auctionDetails!.sellerId)
        : [];
    }
  }, [fetchedData?.availableBens, wizardData.auctionType, wizardData.judicialProcess, wizardData.auctionDetails?.sellerId]);

  const handleNextStep = () => {
    if (currentStepId === 'auction') {
      if (!wizardData.auctionDetails?.title || !wizardData.auctionDetails.auctioneerId || !wizardData.auctionDetails.sellerId) {
        toast({ title: "Campos Obrigatórios", description: "Por favor, preencha o título, leiloeiro e comitente do leilão.", variant: "destructive" });
        return;
      }
    }
    nextStep();
  };
  
  const handleProcessCreated = async (newProcessId?: string) => {
    toast({ title: "Sucesso!", description: "Processo judicial cadastrado." });
    setIsDataRefetching(true);
    await refetchData(newProcessId);
    setWizardMode('main');
    setIsDataRefetching(false);
  }
  
  const handleBemCreated = async () => {
    toast({ title: "Sucesso!", description: "Bem cadastrado com sucesso." });
    setIsDataRefetching(true);
    await refetchData(wizardData.judicialProcess?.id);
    setWizardMode('main');
    setIsDataRefetching(false);
  }

  const renderStep = () => {
    if (isLoading || !fetchedData) {
      return <div className="flex items-center justify-center h-full min-h-[250px]"><Loader2 className="h-8 w-8 animate-spin text-primary" /></div>;
    }
    
    if (wizardMode === 'judicial_process') {
      return (
        <JudicialProcessForm
          courts={fetchedData.courts}
          allDistricts={fetchedData.districts}
          allBranches={fetchedData.branches}
          sellers={fetchedData.sellers}
          onSubmitAction={createJudicialProcessAction}
          onSuccess={handleProcessCreated}
          onCancel={() => setWizardMode('main')}
          formTitle="Novo Processo Judicial (Wizard)"
          formDescription="Cadastre o processo. Você retornará ao assistente de leilão após salvar."
          submitButtonText="Criar e Voltar para o Leilão"
        />
      );
    }
    
    if (wizardMode === 'bem') {
      return (
        <BemForm
          initialData={{
            judicialProcessId: wizardData.auctionType === 'JUDICIAL' ? wizardData.judicialProcess?.id : undefined,
            sellerId: wizardData.auctionType !== 'JUDICIAL' ? wizardData.auctionDetails?.sellerId : undefined,
            status: 'DISPONIVEL',
          }}
          processes={fetchedData.judicialProcesses}
          categories={fetchedData.categories}
          sellers={fetchedData.sellers}
          onSubmitAction={createBemAction}
          onSuccess={handleBemCreated}
          onCancel={() => setWizardMode('main')}
          formTitle="Novo Bem (Wizard)"
          formDescription="Cadastre o bem. Ele ficará disponível para loteamento ao salvar."
          submitButtonText="Criar e Voltar ao Loteamento"
        />
      );
    }

    switch (currentStepId) {
      case 'type': return <Step1TypeSelection />;
      case 'judicial': return <Step2JudicialSetup processes={fetchedData.judicialProcesses} onAddNewProcess={() => setWizardMode('judicial_process')} onRefetchRequest={() => refetchData()} />;
      case 'auction': return <Step3AuctionDetails categories={fetchedData.categories} auctioneers={fetchedData.auctioneers} sellers={fetchedData.sellers} />;
      case 'lotting': {
        return <Step4Lotting 
                  availableBens={bensForLotting} 
                  auctionData={wizardData.auctionDetails as Partial<Auction>} 
               />;
      }
      case 'review': return <Step5Review />;
      default: return <div className="text-center py-10"><p>Etapa "{stepsToUse[currentStep]?.title || 'Próxima'}" em desenvolvimento.</p></div>;
    }
  };

  return (
    <>
      <div className="space-y-6">
        <Card className="shadow-lg">
          <CardHeader>
              <CardTitle className="text-2xl font-bold font-headline flex items-center">
                <Rocket className="h-7 w-7 mr-3 text-primary" />
                Assistente de Criação de Leilão
              </CardTitle>
              <CardDescription>Siga os passos para criar um novo leilão de forma completa e guiada.</CardDescription>
            </CardHeader>
          {wizardMode === 'main' ? (
            <>
              <CardContent className="p-6">
                <WizardStepper steps={stepsToUse} currentStep={currentStep} onStepClick={goToStep} />
                <div className="mt-8 p-6 border rounded-lg bg-background min-h-[300px]">
                  {renderStep()}
                </div>
              </CardContent>
              <CardFooter className="mt-8 flex justify-between p-6 pt-0">
                <Button variant="outline" onClick={prevStep} disabled={currentStep === 0 || isLoading || isDataRefetching}>
                  <ChevronLeft className="mr-2 h-4 w-4" /> Anterior
                </Button>

                <div className="flex items-center gap-2">
                    {currentStepId === 'lotting' && (
                        <Button variant="secondary" type="button" onClick={() => setWizardMode('bem')} disabled={isLoading || isDataRefetching}>
                            <PackagePlus className="mr-2 h-4 w-4" /> Cadastrar Novo Bem
                        </Button>
                    )}
                    {currentStep < stepsToUse.length - 1 && (
                    <Button onClick={handleNextStep} disabled={isLoading || isDataRefetching}>
                        {isDataRefetching ? <Loader2 className="h-4 w-4 animate-spin mr-2"/> : null}
                        Próximo <ChevronRight className="ml-2 h-4 w-4" />
                    </Button>
                    )}
                </div>
              </CardFooter>
            </>
          ) : (
            <CardContent className="p-6">
              {renderStep()}
            </CardContent>
          )}
        </Card>
        
        <Card className="shadow-lg mt-8">
          <CardHeader className="flex flex-row justify-between items-center">
            <div>
              <CardTitle className="text-xl font-semibold flex items-center"><Workflow className="h-5 w-5 mr-2 text-primary" /> Visualização do Fluxo</CardTitle>
              <CardDescription>Uma visão geral do progresso atual do seu cadastro.</CardDescription>
            </div>
            <Button variant="outline" size="sm" onClick={() => setIsFlowModalOpen(true)}>
              <Expand className="mr-2 h-4 w-4" /> Visão Ampliada
            </Button>
          </CardHeader>
          <CardContent className="h-96 w-full p-0">
            <WizardFlow />
          </CardContent>
        </Card>
      </div>
      
      <WizardFlowModal isOpen={isFlowModalOpen} onClose={() => setIsFlowModalOpen(false)} />
    </>
  );
}

function WizardPageContent() {
    const [fetchedData, setFetchedData] = useState<WizardDataForFetching | null>(null);
    const [isLoadingData, setIsLoadingData] = useState(true);
    const { setWizardData } = useWizard(); // useWizard must be used within WizardProvider

    const loadData = useCallback(async (newProcessIdToSelect?: string) => {
        setIsLoadingData(true);
        const result = await getWizardInitialData();
        if (result.success) {
            const data = result.data as WizardDataForFetching;
            setFetchedData(data);
            
            if (newProcessIdToSelect) {
                const newProcess = data.judicialProcesses.find(p => p.id === newProcessIdToSelect);
                if (newProcess) {
                    setWizardData(prev => ({...prev, judicialProcess: newProcess}));
                }
            }
        } else {
            console.error("Failed to load wizard data:", result.message);
        }
        setIsLoadingData(false);
    }, [setWizardData]);

    useEffect(() => {
        loadData();
    }, [loadData]);

    if (isLoadingData) {
      return (
        <div className="flex justify-center items-center min-h-[calc(100vh-10rem)]">
          <Loader2 className="h-12 w-12 animate-spin text-primary" />
        </div>
      );
    }
    
    if (!fetchedData) {
        return <div className="text-center py-10">Erro ao carregar dados do assistente.</div>
    }

    return (
      <WizardContent 
        fetchedData={fetchedData} 
        isLoading={isLoadingData} 
        refetchData={loadData} 
      />
    );
}


export default function WizardPage() {
  return (
    <WizardProvider>
      <WizardPageContent />
    </WizardProvider>
  );
}
```
- src/components/admin/wizard/steps/step-2-judicial-setup.tsx:
```tsx

// src/components/admin/wizard/steps/step-2-judicial-setup.tsx
'use client';

import { useWizard } from '../wizard-context';
import type { JudicialProcess } from '@/types';
import EntitySelector from '@/components/ui/entity-selector';
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { PlusCircle } from 'lucide-react';

interface Step2JudicialSetupProps {
  processes: JudicialProcess[];
  onRefetchRequest: () => void;
  onAddNewProcess?: () => void;
}

export default function Step2JudicialSetup({ processes, onRefetchRequest, onAddNewProcess }: Step2JudicialSetupProps) {
  const { wizardData, setWizardData } = useWizard();
  const [isFetching, setIsFetching] = useState(false);

  const selectedProcess = wizardData.judicialProcess;
  
  const handleRefetch = async () => {
      setIsFetching(true);
      await onRefetchRequest();
      setIsFetching(false);
  }

  const handleAddNew = () => {
    if (onAddNewProcess) {
      onAddNewProcess();
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-2">
        <h3 className="text-lg font-semibold">Selecione o Processo Judicial</h3>
        <Button variant="secondary" onClick={handleAddNew}>
            <PlusCircle className="mr-2 h-4 w-4"/>
            Cadastrar Novo Processo
        </Button>
      </div>
      <EntitySelector
        value={selectedProcess?.id}
        onChange={(processId) => {
            const process = processes.find(p => p.id === processId) || undefined;
            setWizardData((prev) => ({ ...prev, judicialProcess: process }));
        }}
        options={processes.map(p => ({ value: p.id, label: p.processNumber }))}
        placeholder="Selecione um processo..."
        searchPlaceholder="Buscar por número..."
        emptyStateMessage="Nenhum processo encontrado."
        createNewUrl="/admin/judicial-processes/new"
        editUrlPrefix="/admin/judicial-processes"
        onRefetch={handleRefetch}
        isFetching={isFetching}
      />
      
      {selectedProcess && (
        <div className="p-4 border rounded-lg bg-secondary/50 space-y-2">
            <h4 className="font-semibold text-md">Detalhes do Processo Selecionado</h4>
            <p className="text-sm"><strong className="text-muted-foreground">Nº do Processo:</strong> {selectedProcess.processNumber}</p>
            <p className="text-sm"><strong className="text-muted-foreground">Vara:</strong> {selectedProcess.branchName}</p>
            <p className="text-sm"><strong className="text-muted-foreground">Comarca:</strong> {selectedProcess.districtName}</p>
            <p className="text-sm"><strong className="text-muted-foreground">Partes:</strong> {selectedProcess.parties.map(p => p.name).join(', ')}</p>
        </div>
      )}
    </div>
  );
}
```
- src/components/admin/wizard/steps/step-3-auction-details.tsx:
```tsx
// src/components/admin/wizard/steps/step-3-auction-details.tsx
'use client';

import { useWizard } from '../wizard-context';
import { useForm, useFieldArray, useWatch } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import type { LotCategory, AuctioneerProfileInfo, SellerProfileInfo, AuctionStage, Auction, StateInfo, CityInfo } from '@/types';
import { Form } from '@/components/ui/form';
import React, { useEffect, useMemo, useCallback, useState } from 'react';
import AuctionForm from '@/app/admin/auctions/auction-form'; // Import the main form

interface Step3AuctionDetailsProps {
  categories: LotCategory[];
  auctioneers: AuctioneerProfileInfo[];
  sellers: SellerProfileInfo[];
}

export default function Step3AuctionDetails({ 
    categories, 
    auctioneers, 
    sellers 
}: Step3AuctionDetailsProps) {
  const { wizardData, setWizardData } = useWizard();
  const [states, setStates] = useState<StateInfo[]>([]);
  const [cities, setCities] = useState<CityInfo[]>([]);

  // The main AuctionForm now handles its own state via react-hook-form.
  // We just need to pass a callback to receive the data when it changes.
  const handleWizardDataChange = (data: Partial<any>) => {
    setWizardData(prev => ({
        ...prev,
        auctionDetails: {
            ...prev.auctionDetails,
            ...data,
            // Ensure derived names are also updated
            auctioneerName: auctioneers.find(a => a.id === data.auctioneerId)?.name,
            sellerName: sellers.find(s => s.id === data.sellerId)?.name,
        }
    }));
  };

  // Determine the correct sellerId based on the auctionType
  const initialSellerId = useMemo(() => {
    if (wizardData.auctionType === 'JUDICIAL') {
        const processSellerId = wizardData.judicialProcess?.sellerId;
        // If the process already has a linked seller, use it.
        if (processSellerId) {
            return processSellerId;
        }
    }
    // Otherwise, use whatever is already in the auction details (if any)
    return wizardData.auctionDetails?.sellerId;
  }, [wizardData.auctionType, wizardData.judicialProcess, wizardData.auctionDetails?.sellerId]);

  // Construct the initial data for the form, ensuring dates are Date objects if they exist
  const initialDataForForm = {
    ...wizardData.auctionDetails,
    sellerId: initialSellerId,
    auctionType: wizardData.auctionType,
    auctionDate: wizardData.auctionDetails?.auctionDate ? new Date(wizardData.auctionDetails.auctionDate) : new Date(),
    endDate: wizardData.auctionDetails?.endDate ? new Date(wizardData.auctionDetails.endDate) : undefined,
    // Deixa o AuctionForm lidar com a lógica de default das stages se elas não existirem.
    // Apenas mapeia para Date objects se já existirem no wizard.
    auctionStages: wizardData.auctionDetails?.auctionStages?.map(stage => ({
        ...stage,
        startDate: stage.startDate ? new Date(stage.startDate) : undefined,
        endDate: stage.endDate ? new Date(stage.endDate) : undefined,
    })),
  };
  
  return (
    <AuctionForm
        // @ts-ignore
        initialData={initialDataForForm}
        categories={categories}
        auctioneers={auctioneers}
        sellers={sellers}
        states={states}
        allCities={cities}
        formTitle="Detalhes do Leilão"
        formDescription="Preencha as informações principais, datas e configurações do leilão."
        isWizardMode={true}
        onWizardDataChange={handleWizardDataChange}
    />
  );
}
```
- src/components/admin/wizard/steps/step-4-lotting.tsx:
```tsx

// src/components/admin/wizard/steps/step-4-lotting.tsx
'use client';

import { useWizard } from '../wizard-context';
import type { Bem, Auction, Lot } from '@/types';
import { useState, useMemo } from 'react';
import { DataTable } from '@/components/ui/data-table';
import { createColumns } from '@/components/admin/lotting/columns';
import { Button } from '@/components/ui/button';
import { Boxes, Box, Eye, FileText, Loader2, AlertCircle, Package } from 'lucide-react';
import CreateLotFromBensModal from '@/components/admin/lotting/create-lot-modal';
import { useToast } from '@/hooks/use-toast';
import { Separator } from '@/components/ui/separator';
import { v4 as uuidv4 } from 'uuid';
import BemDetailsModal from '@/components/admin/bens/bem-details-modal';

interface Step4LottingProps {
  availableBens: Bem[];
  auctionData: Partial<Auction>;
}

export default function Step4Lotting({ availableBens, auctionData }: Step4LottingProps) {
  const { wizardData, setWizardData } = useWizard();
  const [rowSelection, setRowSelection] = useState({});
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isBemModalOpen, setIsBemModalOpen] = useState(false);
  const [selectedBemForModal, setSelectedBemForModal] = useState<Bem | null>(null);
  const { toast } = useToast();
  const [isCreatingIndividualLots, setIsCreatingIndividualLots] = useState(false);

  const bensForLotting = useMemo(() => {
    // Filter out bens that have already been lotted in this wizard session
    const lottedBemIds = new Set(wizardData.createdLots?.flatMap(lot => lot.bemIds || []) || []);
    return availableBens.filter(bem => bem.status === 'DISPONIVEL' && !lottedBemIds.has(bem.id));
  }, [availableBens, wizardData.createdLots]);

  const selectedBens = useMemo(() => {
    const selectedIndices = Object.keys(rowSelection).map(Number);
    return selectedIndices.map(index => bensForLotting[index]).filter(Boolean) as Bem[];
  }, [rowSelection, bensForLotting]);
  
  const handleViewBemDetails = (bem: Bem) => {
    setSelectedBemForModal(bem);
    setIsBemModalOpen(true);
  };
  
  const columns = useMemo(() => createColumns({ onOpenDetails: handleViewBemDetails }), []);

  
  const handleCreateGroupedLotClick = () => {
    if (selectedBens.length === 0) {
      toast({
        title: "Nenhum bem selecionado",
        description: "Por favor, selecione um ou mais bens da lista para criar um lote.",
        variant: "destructive"
      });
      return;
    }
    setIsModalOpen(true);
  };

  const handleCreateIndividualLotsClick = () => {
    if (selectedBens.length === 0) {
      toast({ title: "Nenhum bem selecionado", variant: "destructive" });
      return;
    }
    setIsCreatingIndividualLots(true);
    const newLots: Lot[] = selectedBens.map((bem, index) => {
      const lotNumber = String((wizardData.createdLots?.length || 0) + index + 1).padStart(3, '0');
      return {
        id: `temp-lot-${uuidv4()}`,
        publicId: `temp-pub-${uuidv4().substring(0,8)}`,
        title: bem.title,
        number: lotNumber,
        price: bem.evaluationValue || 0,
        initialPrice: bem.evaluationValue || 0,
        bemIds: [bem.id],
        status: 'EM_BREVE',
        categoryId: bem.categoryId,
        subcategoryId: bem.subcategoryId,
        auctionId: auctionData.id || 'TBD',
        imageUrl: bem.imageUrl,
        dataAiHint: bem.dataAiHint,
      } as Lot;
    });

    setWizardData(prev => ({
        ...prev,
        createdLots: [...(prev.createdLots || []), ...newLots]
    }));
    toast({ title: "Sucesso!", description: `${newLots.length} lote(s) individuais preparados.` });
    setRowSelection({});
    setIsCreatingIndividualLots(false);
  };
  
  const handleLotCreatedInModal = (newLotData: Omit<Lot, 'id' | 'publicId' | 'createdAt' | 'updatedAt' | 'auctionId'>) => {
    const newCompleteLot: Lot = {
        ...(newLotData as Lot),
        id: `temp-lot-${uuidv4()}`,
        publicId: `temp-pub-${uuidv4().substring(0,8)}`,
        auctionId: auctionData.id || 'TBD',
        createdAt: new Date(),
        updatedAt: new Date(),
    };
    setWizardData(prev => ({
        ...prev,
        createdLots: [...(prev.createdLots || []), newCompleteLot]
    }));
    setRowSelection({});
  }

  return (
    <>
      <div className="space-y-4">
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
            <div>
                <h3 className="text-lg font-semibold">Loteamento de Bens</h3>
                <p className="text-sm text-muted-foreground">Selecione os bens disponíveis para criar lotes individuais ou agrupados.</p>
            </div>
            <div className="flex gap-2 w-full sm:w-auto flex-wrap justify-end">
                <Button onClick={handleCreateIndividualLotsClick} variant="outline" className="flex-1" disabled={selectedBens.length === 0 || isCreatingIndividualLots}>
                    <Box className="mr-2 h-4 w-4" /> Lotear Individualmente
                </Button>
                <Button onClick={handleCreateGroupedLotClick} className="flex-1" disabled={selectedBens.length === 0 || isCreatingIndividualLots}>
                    <Boxes className="mr-2 h-4 w-4" /> Agrupar em Lote Único
                </Button>
            </div>
        </div>
        
        <DataTable
          columns={columns}
          data={bensForLotting}
          rowSelection={rowSelection}
          setRowSelection={setRowSelection}
          searchColumnId="title"
          searchPlaceholder="Buscar por título do bem..."
        />
      </div>

      {wizardData.createdLots && wizardData.createdLots.length > 0 && (
        <div className="mt-6">
            <Separator className="my-4" />
            <h4 className="text-md font-semibold mb-2">Lotes Preparados Nesta Sessão ({wizardData.createdLots.length})</h4>
            <div className="space-y-2 rounded-md border p-2 max-h-48 overflow-y-auto">
                {wizardData.createdLots.map(lot => (
                    <div key={lot.id} className="text-sm p-2 bg-secondary/50 rounded-md">
                        <p className="font-medium">Lote {lot.number}: {lot.title}</p>
                        <p className="text-xs text-muted-foreground">
                            {lot.bemIds?.length} bem(ns) | Lance Inicial: R$ {lot.initialPrice?.toLocaleString('pt-br')}
                        </p>
                    </div>
                ))}
            </div>
        </div>
      )}

      {isModalOpen && <CreateLotFromBensModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        selectedBens={selectedBens}
        onLotCreated={handleLotCreatedInModal}
      />}
       <BemDetailsModal 
        bem={selectedBemForModal} 
        isOpen={isBemModalOpen} 
        onClose={() => setIsBemModalOpen(false)} 
      />
    </>
  );
}

```
- src/components/admin/wizard/steps/step-5-review.tsx:
```tsx
// src/components/admin/wizard/steps/step-5-review.tsx
'use client';

import { useWizard } from '../wizard-context';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { CheckCircle, Gavel, FileText, Package, ListChecks, CalendarDays, User, Users, Rocket, Loader2 } from 'lucide-react';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { Button } from '@/components/ui/button';
import { useState } from 'react';
import { useToast } from '@/hooks/use-toast';
import { useRouter } from 'next/navigation';
import { createAuctionFromWizard } from '@/app/admin/wizard/actions';
import AuctionStagesTimeline from '@/components/auction/auction-stages-timeline';

export default function Step5Review() {
  const { wizardData, resetWizard } = useWizard();
  const [isPublishing, setIsPublishing] = useState(false);
  const { toast } = useToast();
  const router = useRouter();


  const {
    auctionType,
    judicialProcess,
    auctionDetails,
    createdLots = [],
  } = wizardData;

  const auctionTypeLabels: Record<string, string> = {
    JUDICIAL: 'Leilão Judicial',
    EXTRAJUDICIAL: 'Leilão Extrajudicial',
    PARTICULAR: 'Leilão Particular',
    TOMADA_DE_PRECOS: 'Tomada de Preços',
  };

  const handlePublish = async () => {
    setIsPublishing(true);
    const result = await createAuctionFromWizard(wizardData);
    if (result.success) {
        toast({
            title: "Leilão Publicado!",
            description: "O leilão e seus lotes foram criados com sucesso.",
        });
        resetWizard();
        router.push(result.auctionId ? `/admin/auctions/${result.auctionId}/edit` : '/admin/auctions');
    } else {
        toast({
            title: "Erro ao Publicar",
            description: result.message,
            variant: "destructive",
        });
        setIsPublishing(false);
    }
  };


  return (
    <div className="space-y-6">
      <h3 className="text-lg font-semibold mb-4">Revise e Confirme as Informações</h3>
      
      {/* Resumo do Leilão */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg font-semibold flex items-center gap-2"><Gavel className="text-primary"/> Detalhes do Leilão</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3 text-sm">
          <p><strong>Título:</strong> <span className="text-muted-foreground">{auctionDetails?.title || 'Não definido'}</span></p>
          <p><strong>Descrição:</strong> <span className="text-muted-foreground">{auctionDetails?.description || 'Não definida'}</span></p>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2">
            <div className="flex items-center gap-2"><strong>Modalidade:</strong> <Badge variant="outline">{auctionTypeLabels[auctionType || ''] || 'Não definida'}</Badge></div>
            <p><strong>Leiloeiro:</strong> <span className="text-muted-foreground">{auctionDetails?.auctioneerName || 'Não definido'}</span></p>
            <p><strong>Comitente:</strong> <span className="text-muted-foreground">{auctionDetails?.sellerName || 'Não definido'}</span></p>
            <p><strong>Data de Início:</strong> <span className="text-muted-foreground">{auctionDetails?.auctionDate ? format(new Date(auctionDetails.auctionDate), 'dd/MM/yyyy', {locale: ptBR}) : 'Não definida'}</span></p>
            {auctionDetails?.endDate && (
                <p><strong>Data de Fim:</strong> <span className="text-muted-foreground">{format(new Date(auctionDetails.endDate), 'dd/MM/yyyy', {locale: ptBR})}</span></p>
            )}
          </div>
          <Separator className="my-3"/>
          <AuctionStagesTimeline auctionOverallStartDate={new Date(auctionDetails?.auctionDate || Date.now())} stages={auctionDetails?.auctionStages || []} />
        </CardContent>
      </Card>

      {/* Resumo do Processo Judicial (se aplicável) */}
      {auctionType === 'JUDICIAL' && judicialProcess && (
        <Card>
          <CardHeader>
            <CardTitle className="text-lg font-semibold flex items-center gap-2"><FileText className="text-primary"/> Processo Judicial Vinculado</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3 text-sm">
            <p><strong>Nº do Processo:</strong> <span className="text-muted-foreground">{judicialProcess.processNumber}</span></p>
            <p><strong>Vara:</strong> <span className="text-muted-foreground">{judicialProcess.branchName}</span></p>
            <p><strong>Comarca:</strong> <span className="text-muted-foreground">{judicialProcess.districtName}</span></p>
            <div>
              <strong className="flex items-center gap-1"><Users/>Partes:</strong>
              <ul className="list-disc list-inside pl-4 text-muted-foreground">
                {judicialProcess.parties.map((party, index) => (
                  <li key={index}><strong>{party.partyType}:</strong> {party.name}</li>
                ))}
              </ul>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Lotes Criados */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg font-semibold flex items-center gap-2"><ListChecks className="text-primary"/> Lotes Criados ({createdLots.length})</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {createdLots.length === 0 ? (
            <p className="text-sm text-muted-foreground text-center py-4">Nenhum lote foi criado nesta sessão.</p>
          ) : (
            createdLots.map((lot, index) => (
              <div key={index} className="p-3 border rounded-md">
                <p className="font-semibold">Lote {lot.number}: {lot.title}</p>
                <p className="text-xs text-muted-foreground">
                    {lot.bemIds?.length} bem(ns) | Lance Inicial: R$ {lot.initialPrice?.toLocaleString('pt-br')}
                </p>
              </div>
            ))
          )}
        </CardContent>
      </Card>
      <div className="text-center p-4 bg-green-50 dark:bg-green-900/20 border border-dashed border-green-500 rounded-lg">
          <CheckCircle className="mx-auto h-8 w-8 text-green-600 mb-2"/>
          <h4 className="text-lg font-semibold text-green-800 dark:text-green-300">Tudo Pronto para Publicar!</h4>
          <p className="text-sm text-muted-foreground mt-1 mb-4">
             Ao clicar em "Publicar Leilão", o leilão e todos os lotes criados serão salvos no banco de dados.
          </p>
          <Button size="lg" onClick={handlePublish} disabled={isPublishing}>
            {isPublishing ? <Loader2 className="animate-spin mr-2" /> : <Rocket className="mr-2 h-5 w-5" />}
            {isPublishing ? "Publicando..." : "Publicar Leilão"}
          </Button>
      </div>
