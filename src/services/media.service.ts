// src/services/media.service.ts
/**
 * @fileoverview Este arquivo contém a classe MediaService, que encapsula a
 * lógica de negócio para o gerenciamento de todos os itens de mídia da plataforma.
 * Atua como intermediário entre as actions (ex: upload de arquivos) e o
 * repositório, garantindo a correta criação e atualização dos metadados
 * de mídia no banco de dados.
 */
import { MediaRepository } from '@/repositories/media.repository';
import type { MediaItem } from '@/types';
import type { Prisma } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';

export class MediaService {
  private repository: MediaRepository;

  constructor() {
    this.repository = new MediaRepository();
  }

  async getMediaItems(): Promise<MediaItem[]> {
    // @ts-ignore
    return this.repository.findAll();
  }

  async getMediaItemById(id: string): Promise<MediaItem | null> {
    // @ts-ignore
    return this.repository.findById(id);
  }

  async createMediaItem(
    itemData: Partial<Omit<MediaItem, 'id'>>,
    url: string,
    userId: BigInt
  ): Promise<{ success: boolean; message: string; item?: MediaItem }> {
    try {
      const dataToCreate: Prisma.MediaItemCreateInput = {
        ...itemData,
        url: url,
        urlThumbnail: url, // Placeholder, could be generated by a separate service
        storagePath: url, // For local adapter, path is the URL
        uploadedById: userId, // Correctly passing the string ID
        judicialProcessId: itemData.judicialProcessId || undefined,
      } as Prisma.MediaItemCreateInput;

      const newItem = await this.repository.create(dataToCreate);
      return { success: true, message: "Mídia criada com sucesso.", item: newItem };
    } catch (error: any) {
      console.error("Error in MediaService.createMediaItem:", error);
      return { success: false, message: `Falha ao criar mídia: ${error.message}` };
    }
  }

  async updateMediaItemMetadata(
    id: string,
    metadata: Partial<Pick<MediaItem, 'title' | 'altText' | 'caption' | 'description'>>
  ): Promise<{ success: boolean; message: string }> {
    try {
      await this.repository.update(id, metadata);
      return { success: true, message: 'Metadados da mídia atualizados.' };
    } catch (error: any) {
      console.error(`Error in MediaService.updateMediaItemMetadata for id ${id}:`, error);
      return { success: false, message: `Falha ao atualizar metadados: ${error.message}` };
    }
  }

  async deleteMediaItem(id: string): Promise<{ success: boolean; message: string }> {
    try {
      // In a real app, you might want to check if this media is in use by lots/auctions.
      await this.repository.delete(id);
      return { success: true, message: 'Item de mídia excluído com sucesso.' };
    } catch (error: any) {
      console.error(`Error in MediaService.deleteMediaItem for id ${id}:`, error);
      return { success: false, message: `Falha ao excluir item de mídia: ${error.message}` };
    }
  }

  async deleteAllMediaItems(): Promise<{ success: boolean; message: string; }> {
    try {
      await this.repository.deleteAll();
      return { success: true, message: 'Todos os itens de mídia foram excluídos.' };
    } catch (error: any) {
      return { success: false, message: 'Falha ao excluir todos os itens de mídia.' };
    }
  }
}
