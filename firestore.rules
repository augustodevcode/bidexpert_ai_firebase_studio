
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAdminEmail() {
      // IMPORTANT: Update this list with your actual admin emails
      return request.auth.token.email in ["admin@bidexpert.com", "augusto.devcode@gmail.com", "analyst@bidexpert.com"];
    }

    function isActualAdmin(userId) {
      return isSignedIn() &&
             exists(/databases/$(database)/documents/users/$(userId)) &&
             get(/databases/$(database)/documents/users/$(userId)).data.roleName == 'ADMINISTRATOR';
    }

    function isDefaultRoleName(roleName) {
      return roleName in ['ADMINISTRATOR', 'USER', 'CONSIGNOR', 'AUCTIONEER'];
    }

    // platformSettings
    match /platformSettings/global {
      allow read: if true;
      allow write: if isActualAdmin(request.auth.uid);
    }

    // Roles Collection
    match /roles/{roleId} {
      allow read: if isSignedIn();
      allow list: if isSignedIn();

      allow create: if isSignedIn() &&
                      (
                        isActualAdmin(request.auth.uid) ||
                        isAdminEmail() // Admin emails can bootstrap default roles
                      ) &&
                      request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                      request.resource.data.name_normalized == request.resource.data.name.upper() &&
                      request.resource.data.permissions is list &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.updatedAt == request.time &&
                      (request.resource.data.description == null || request.resource.data.description is string) &&
                      // Ensure only expected fields are present (name, name_normalized, permissions, createdAt, updatedAt, description)
                      request.resource.data.keys().hasOnly(['name', 'name_normalized', 'description', 'permissions', 'createdAt', 'updatedAt']);

      allow update: if isSignedIn() && isActualAdmin(request.auth.uid) &&
                      request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                      request.resource.data.name_normalized == request.resource.data.name.upper() &&
                      (!isDefaultRoleName(resource.data.name) || request.resource.data.name == resource.data.name) && // Prevent renaming default roles away from their default name
                      request.resource.data.permissions is list &&
                      request.resource.data.updatedAt == request.time &&
                      (request.resource.data.description == null || request.resource.data.description is string) &&
                       // Allow only these fields to be updated, plus ensure no new fields are added that are not these
                      request.resource.data.keys().hasOnly(['name', 'name_normalized', 'description', 'permissions', 'createdAt', 'updatedAt']) &&
                      // Prevent modification of createdAt
                      request.resource.data.createdAt == resource.data.createdAt;


      allow delete: if isSignedIn() && isActualAdmin(request.auth.uid) &&
                       !isDefaultRoleName(resource.data.name);
    }

    // Users Collection
    match /users/{userId} {
      allow read, get: if isUser(userId) || isActualAdmin(request.auth.uid);
      allow list: if isActualAdmin(request.auth.uid);

      allow create: if isUser(userId) &&
                       request.resource.data.email == request.auth.token.email &&
                       (
                         !request.resource.data.keys().hasAny(['roleId', 'roleName']) ||
                         request.resource.data.roleId == null ||
                         (
                           request.resource.data.roleId is string &&
                           exists(/databases/$(database)/documents/roles/$(request.resource.data.roleId)) &&
                           get(/databases/$(database)/documents/roles/$(request.resource.data.roleId)).data.name == 'USER'
                         )
                       ) &&
                       request.resource.data.keys().hasAll(['uid', 'email', 'fullName', 'status', 'createdAt', 'updatedAt']) &&
                       (request.resource.data.optInMarketing == null || request.resource.data.optInMarketing is bool) &&
                       (request.resource.data.roleId == null || request.resource.data.roleId is string) &&
                       (request.resource.data.roleName == null || request.resource.data.roleName is string) &&
                       // Allow other optional fields only if they are of correct type
                       (request.resource.data.cpf == null || request.resource.data.cpf is string) &&
                       (request.resource.data.dateOfBirth == null || request.resource.data.dateOfBirth is timestamp);
                       // Add more optional fields here as needed

      allow update: if
                      // 1. Admin email bootstrapping THEMSELVES to ADMINISTRATOR role
                      (
                        isAdminEmail() && isUser(userId) &&
                        (resource.data.roleName == null || resource.data.roleName != 'ADMINISTRATOR') && // Only if not already admin
                        request.resource.data.roleName == 'ADMINISTRATOR' &&
                        request.resource.data.roleId is string && // roleId must be provided
                        request.resource.data.updatedAt == request.time &&
                        // Check that only allowed fields are being changed during this specific bootstrap
                        request.resource.data.keys().hasAll(['roleId', 'roleName', 'updatedAt', 'uid', 'email', 'fullName', 'status', 'createdAt', 'optInMarketing']) && // Ensure basic fields are there if they exist
                        (request.resource.data.size() <= 10) // Example size limit, adjust based on what ensureUserRole... writes
                      ) ||
                      // 2. An actual admin managing any user's roleId/roleName/status or other fields
                      (
                        isActualAdmin(request.auth.uid) &&
                        (
                          // Admin can change roleId, roleName, status, and other permitted fields
                          request.resource.data.keys().hasAny(['roleId', 'roleName', 'status']) ||
                          // Or admin is updating other fields that a normal user can update on themselves
                          !request.resource.data.keys().hasAny(['uid', 'email', 'createdAt']) // uid, email, createdAt are immutable
                        )
                      ) ||
                      // 3. User updating their own profile (but not roleId, roleName, status, uid, email, createdAt)
                      (
                        isUser(userId) &&
                        !request.resource.data.keys().hasAny(['roleId', 'roleName', 'status', 'uid', 'email', 'createdAt'])
                      );

      allow delete: if isActualAdmin(request.auth.uid); // Only actual admins can delete user documents
    }

    // LotCategories Collection
    match /lotCategories/{categoryId} {
      allow read: if true;
      allow list: if true;
      allow create, update, delete: if isSignedIn() && isActualAdmin(request.auth.uid);
    }

    // States Collection
    match /states/{stateId} {
      allow read: if true;
      allow list: if true;
      allow create, update, delete: if isSignedIn() && isActualAdmin(request.auth.uid);
    }

    // Cities Collection
    match /cities/{cityId} {
      allow read: if true;
      allow list: if true;
      allow create, update, delete: if isSignedIn() && isActualAdmin(request.auth.uid);
    }

    // Auctioneers Collection
    match /auctioneers/{auctioneerId} {
      allow read: if true;
      allow list: if true;
      allow create, update, delete: if isSignedIn() && isActualAdmin(request.auth.uid);
    }

    // Sellers Collection
    match /sellers/{sellerId} {
      allow read: if true;
      allow list: if true;
      allow create: if isSignedIn() && isActualAdmin(request.auth.uid);
      allow update: if isSignedIn() && (isActualAdmin(request.auth.uid) || (isUser(resource.data.userId) && !request.resource.data.keys().hasAny(['userId', 'roleId', 'roleName'])));
      allow delete: if isSignedIn() && isActualAdmin(request.auth.uid);
    }

    // Auctions Collection
    match /auctions/{auctionId} {
      allow read: if true;
      allow list: if true;
      allow create, update, delete: if isSignedIn() && isActualAdmin(request.auth.uid);
    }

    // Lots Collection
    match /lots/{lotId} {
      allow read: if true;
      allow list: if true;
      allow create, update, delete: if isSignedIn() && isActualAdmin(request.auth.uid);
    }

    // MediaItems Collection
    match /mediaItems/{mediaItemId} {
      allow read: if true;
      allow list: if isSignedIn(); // Allow authenticated users to list (e.g., for selection)
      allow create: if isSignedIn(); // Allow any authenticated user to upload
      allow update: if isSignedIn() && isActualAdmin(request.auth.uid); // Only admins can update metadata for now
      allow delete: if isSignedIn() && isActualAdmin(request.auth.uid); // Only admins can delete for now
    }
  }
}

    